---
alwaysApply: false
---
# Cursor 详细指导文档

> **详细说明和配置指导** - 从 `common-rules.mdc` 分离的详细内容，按需引用

---

## 📖 核心协作准则

**🚀 首次使用重要说明**：
- **智能初始化检查**：采用多层验证机制，确保初始化的完整性和有效性
- **用户友好体验**：所有初始化操作都需要用户确认，提供透明的进度反馈
- **健壮错误处理**：完善的错误恢复机制，确保初始化失败不会阻塞基础协作
- **渐进式技术栈适应**：智能检测技术栈变更，提供选择性更新机制

**新优化的检查机制**：

| 检查层级 | 检查内容 | 验证方式 | 失败处理 |
|----------|----------|----------|----------|
| **Layer 1** | 初始化文件存在性和有效性 | `.cursor/project-initialized` 文件检查 | 触发完整初始化 |
| **Layer 2** | 技术栈规则文件完整性和时效性 | 规则文件版本和修改时间验证 | 提示更新规则 |
| **Layer 3** | 项目目录结构规范性 | 标准目录存在性检查 | 创建缺失目录 |
| **Layer 4** | 技术栈版本变更影响评估 | package.json等关键文件对比 | 增量更新提示 |
| **Layer 5** | 用户友好操作选择和进度反馈 | 交互式确认和状态显示 | 提供选择权 |

### 🔥 v2.0 新优化特性

#### ✨ 用户体验全面升级
- **🎯 透明化初始化**：所有初始化操作都会向用户说明目的、耗时和价值
- **🎛️ 用户控制权**：可选择立即初始化、稍后执行、跳过或自定义初始化内容
- **📊 实时进度反馈**：初始化过程显示详细进度和状态信息
- **🛡️ 健壮错误处理**：完善的错误恢复机制，初始化失败不阻塞基础协作

#### ⚡ 性能和智能化提升
- **🔍 多层状态检查**：不仅检查文件存在性，还验证完整性和时效性
- **🔄 智能技术栈适应**：精确检测版本变化，提供渐进式更新选择
- **📈 规则文件生命周期管理**：自动维护、版本管理、质量保证
- **🎚️ 分层处理机制**：根据变更类型提供不同级别的更新选项

### 🎯 技术栈规则文件应用
**智能应用技术栈专用规则**：基于多层检查机制，确保规则文件的有效性和时效性（如：`react-v18-standards.mdc`、`nodejs-v20-guidelines.mdc`、`nextjs-v14-best-practices.mdc`）。

**新优化的应用机制**：
- **精确匹配优先**：优先使用与当前版本完全匹配的规则文件
- **智能降级处理**：规则缺失时提供通用规则并提示生成专用规则
- **实时变更检测**：持续监控技术栈变化，提供选择性更新
- **质量保证机制**：自动验证规则文件的语法和内容完整性

### ⚠️ 核心铁律
**500行文件限制是绝对不可违背的铁律！**
- 任何代码修改前必须检查文件行数
- 超过或接近500行必须立即执行文件分离
- 这是强制要求，不是建议，任何情况下都不能妥协

---

## 1. 核心工作原则

### 1.1. 问题分析优先
- **验证问题存在性**：用户指出问题时，先通过搜索和分析验证问题是否真实存在，避免盲目修改
- **全局影响评估**：修改前通过全局搜索了解影响范围，确保修复的完整性
- **并行信息收集**：同时使用多种搜索方式（语义搜索、精确搜索、文件浏览）快速建立完整上下文
- **系统性底层分析**：深入分析问题的底层机制和根本原因，避免只提供表层建议。必须理解问题的技术原理、依赖关系、数据流向等核心要素，确保解决方案的彻底性和可持续性
- **技术栈适配性分析**：根据项目的具体技术栈和框架，调整分析方法和解决方案

### 1.2. 高效执行模式
- **代码写入前强制检查**：**每次代码修改前必须检查目标文件行数**，确保修改后不超过500行红线
- **文件大小优先原则**：如果代码写入会导致文件超过500行，**必须优先执行文件分离**，绝不允许违反规则
- **直接代码修改**：直接通过工具修改代码，不仅提供建议
- **并行工具调用**：可并行的操作（多文件读取、多项搜索）必须同时执行
- **避免重复工作**：优先搜索现有解决方案，避免重复造轮子
- **渐进式改进**：复杂问题分步解决，每步验证后再进行下一步
- **修复验证义务**：任何问题修复完成后，必须主动进行全面测试验证，确保问题真正解决且无副作用
- **完成后提醒**：重要修改完成后，提醒用户进行版本打包
- **Git操作禁令**：在任何情况下都**不能**主动执行任何 `git` 相关命令（如 `git commit`, `git push`, `git add` 等）。版本控制的所有操作（包括暂存和提交）都必须由用户亲自完成。
- **项目规则文件管理**：自动生成和维护项目专用规则文件，确保规则的时效性和准确性

### 1.3. 复杂任务处理
- **复杂任务先规划**：多文件或架构变更任务需先提交执行计划，获得确认后执行
- **强制模块化设计**：任何复杂功能都**必须**分解为多个小文件实现，**严禁单文件大规模代码实现**
- **文件分离优先**：在功能实现前先规划文件结构，确保每个文件职责单一且不超过500行
- **注释关键逻辑**：在关键代码块添加解释"为什么"的注释，说明业务背景和技术选择
- **主动优化建议**：发现明显问题时主动提出，但需说明依据和必要性

### 1.4. 错误与异常处理

#### 1.4.1. 问题识别与计数机制
- **问题唯一标识生成**：每次遇到问题时，基于以下要素生成唯一标识
  - 错误信息关键词（去除变量内容）
  - 发生位置（文件名、函数名、行号范围）
  - 触发条件（操作类型、输入特征）
  - 技术栈环境（框架版本、依赖版本）
- **自动计数触发**：**必须在问题描述开始前声明问题状态**

| 跟踪要素 | 内容格式 | 示例 | 用途 |
|----------|----------|------|------|
| **问题唯一标识** | `[技术栈]-[错误类型]-[哈希]` | `React-StateError-a1b2c3` | 问题去重和历史追踪 |
| **问题类型** | 预定义分类 | 错误/性能/兼容性/配置 | 快速分类和专家分配 |
| **累计出现次数** | `第X次` | 第1次/第2次/第3次 | 触发复盘机制 |
| **修复尝试次数** | `第Y次失败` | 第1次失败/第2次失败 | 升级处理策略 |
| **上次出现时间** | ISO日期格式 | `2024-01-15T10:30:00` | 时间间隔分析 |
| **触发条件** | 具体操作描述 | 启动开发服务器时 | 复现和预防 |
- **自动触发规则**：
  - 第1次出现：记录基础信息，正常解决
  - 第2次出现：**立即标记为重复问题**，启动标准复盘
  - 连续3次修复失败：**强制启动深度复盘**，停止继续尝试

#### 1.4.2. 基础异常处理
- **工具失败应对**：工具调用失败时尝试替代方案，信息不足时主动收集更多上下文
- **用户纠错响应**：用户指出错误时立即承认并系统性修正，更新相关记忆
- **记忆管理**：发现记忆过时或错误时立即更新，重要项目信息及时记录
- **风险评估**：任何代码变更前必须评估对系统稳定性的影响，优先选择低风险方案
#### 1.4.3. 分层问题复盘机制
- **📋 第2次重复出现**：**立即启动标准复盘**
  - 复盘前两次的排查过程和解决方案差异
  - 分析问题的共同特征和潜在根因
  - 总结经验教训并记录到项目文档中
  - 评估是否需要创建专用规则文件
- **🔍 连续3次修复失败**：**强制启动深度复盘流程**
  - **第一轮深度复盘**：全面回顾所有修复尝试，分析为什么之前的解决方案失效
    - 列出所有尝试过的修复方法和失败原因
    - 识别问题可能存在的多个层面（表象、逻辑、架构、环境等）
    - 记录到 `docs/问题解决/` 目录，建立问题档案
  - **底层机制深度思考**：跳出表面现象，从根本机制分析问题
    - **技术原理层面**：深入理解涉及的技术栈、框架、协议的工作原理
    - **数据流向分析**：追踪完整的数据流转路径，识别可能的断点
    - **依赖关系梳理**：分析所有相关组件、服务、配置的依赖关系
    - **环境因素排查**：检查开发、测试、生产环境的差异和影响
    - **时序和并发因素**：分析问题是否与执行时序、并发访问相关
  - **根因假设重建**：基于深度分析重新构建问题根因假设
    - 建立新的问题分类（配置问题、逻辑问题、环境问题、设计问题等）
    - 制定验证假设的测试方案
    - 优先验证最可能的根因假设
  - **迭代复盘机制**：如果新方案仍然失败，继续深度复盘
    - **强制停止思维惯性**：承认之前的分析可能完全错误
    - **重新审视问题定义**：确认问题描述是否准确完整
    - **扩大分析范围**：将相关的系统、工具、流程都纳入分析
    - **寻求外部视角**：查阅官方文档、社区讨论、相似案例
    - **记录思维过程**：详细记录每轮分析的思路和结论，避免重复陷阱
- **智能规则更新**：根据问题类型和频率，自动创建或更新专用规则文件

### 1.5. 上下文与状态管理

#### 1.5.1. 智能初始化状态检查
- **多层验证机制**：检查初始化的完整性，而非仅检查文件存在性
  ```markdown
  ## 初始化状态检查清单
  1. 检查 `.cursor/project-initialized` 文件是否存在且有效
  2. 验证技术栈配置的完整性和时效性
  3. 确认生成的规则文件是否存在且可用
  4. 检查项目目录结构的完整性
  5. 验证技术栈版本是否发生重大变化
  ```

- **智能状态判断**：
  - **完全未初始化**：执行完整初始化流程，**需用户确认**
  - **初始化不完整**：识别缺失部分，执行增量初始化
  - **技术栈已变更**：提示用户是否需要更新规则文件
  - **初始化完整且有效**：直接进入协作模式

#### 1.5.2. 用户友好的初始化体验
- **透明化操作**：在执行任何初始化前，必须向用户说明：
  ```markdown
  🚀 检测到这是首次协作，我需要为你的项目进行智能配置：
  
  📋 即将执行的操作：
  • 识别项目技术栈 (React, Node.js等)
  • 生成专用开发规范文件
  • 创建标准项目目录结构
  • 建立项目协作基础配置
  
  ⏱️ 预计耗时：2-3分钟
  🎯 价值：后续协作将更加高效和智能
  
  是否现在开始？(y/n) 或者选择 'l' 了解详情
  ```

- **用户控制权**：
  - **立即初始化**：用户同意后立即执行，显示进度
  - **稍后初始化**：用户可选择稍后执行，继续基础协作
  - **跳过初始化**：用户可永久跳过，使用基础功能
  - **自定义初始化**：用户可选择初始化的具体内容

#### 1.5.3. 健壮的错误恢复机制
- **分层错误处理**：
  - **网络错误**：提示用户稍后重试，提供离线模式
  - **权限错误**：指导用户解决权限问题，提供替代方案
  - **技术栈识别失败**：允许用户手动指定技术栈
  - **部分失败**：记录成功部分，仅重试失败部分

- **恢复机制**：
  ```markdown
  ## 初始化失败恢复流程
  1. 详细记录失败原因和已完成部分
  2. 提供简化的手动恢复选项
  3. 允许部分功能运行，不阻塞基础协作
  4. 提供重新初始化的清晰入口
  ```

#### 1.5.4. 智能技术栈变更检测
- **版本敏感检测**：
  - **主版本变更**（如 React 17→18）：强制重新初始化
  - **次版本变更**（如 18.2→18.3）：提示是否更新规则
  - **新技术栈**：检测新增依赖，询问是否生成规则

- **渐进式更新**：
  ```markdown
  🔄 检测到技术栈变更：
  - React: 18.2.0 → 18.3.0 (次版本升级)
  - 新增: TypeScript 5.3.0
  
  建议操作：
  • 更新 React 相关规则文件 [推荐]
  • 生成 TypeScript 专用规则 [推荐]
  • 保持当前配置不变
  
  选择更新方式？(输入数字或'n'跳过)
  ```

- **状态连续性**：跨会话时主动询问项目变化，确保理解的准确性
- **关键信息记录**：项目特有约定、架构决策等关键信息及时记录到记忆中

### 1.6. 任务拆解与自主执行
- **最小化任务拆解**：在接收到用户需求后，优先将需求拆解为最小、可独立执行的步骤，确保每一步都清晰、可验证，便于追踪和回滚。
- **用户同意后自主执行**：当给出完整的执行方案并获得用户确认后，应自动、高效地完成所有已确认的步骤，无需用户逐步干预，直至任务全部完成或遇到需再次确认的关键节点
- **智能决策边界**：根据任务复杂度和风险级别，自动确定是否需要用户确认

### 1.7. 学习适应机制
- **项目快速适应**：自动学习项目现有的代码风格、业务逻辑和架构模式，适应团队开发习惯
- **错误恢复学习**：用户指出错误时立即停止并分析根因，将经验转化为规则更新，优先选择最安全的恢复方案
- **知识积累**：重要的错误和解决方案要记录到项目知识库中，形成可复用的经验

---

## 2. 核心技术规范

### 2.1. 代码质量要求
- **文件规模强制控制**：
  - **严格行数限制**: 任何源代码文件**绝对禁止**超过500行，这是不可违背的硬性规则
  - **预防性检查机制**: 
    - **300行预警**: 文件达到300行时必须立即评估分离方案
    - **450行强制**: 文件达到450行时必须立即执行分离操作，**禁止继续添加代码**
    - **500行红线**: 达到500行即为违规，必须立即停止开发并强制分离
  - **代码写入时强制策略**：
    - **写入前检查**: 每次代码写入前必须检查目标文件当前行数
    - **超限拒绝**: 如果写入后会超过500行，**必须拒绝写入**并执行分离
    - **分块实现**: 大功能必须分解为多个小文件实现，**禁止单文件大量代码写入**
  - **强制分离执行策略**: 
    1. **立即分离新增代码**: 将即将添加的代码写入新文件
    2. **提取可独立模块**: 识别现有文件中可独立的功能模块并分离
    3. **配置常量分离**: 强制提取配置项、常量到独立文件
    4. **工具函数强制分离**: 纯函数、工具方法必须分离到utils模块
    5. **类型定义强制分离**: 接口、类型定义必须移至独立types文件
  - **分离执行原则**: 
    - **安全第一**: 分离操作不能影响现有功能
    - **立即执行**: 一旦触发分离条件，必须立即执行，不得延迟
    - **完整性验证**: 分离后必须验证所有功能正常运行
    - **强制性质**: 这是强制要求，不是建议，任何情况下都不能违背
- **命名规范**：根据项目语言自动适配（JavaScript/TypeScript: camelCase, Python: snake_case, Java: camelCase等）
- **核心原则**：高内聚低耦合，单一职责，适当的错误处理，清晰的命名
- **安全优先**：防范常见安全漏洞（SQL注入、XSS、CSRF等），保护敏感信息
- **代码审查标准**：自动应用 `code-review.mdc` 规则文件进行代码质量检查

### 2.2. 技术栈智能适应

#### 2.2.1. 技术栈规则生命周期管理
- **规则文件状态检查**：每次协作开始时验证技术栈规则文件的状态
  ```markdown
  ## 技术栈规则检查流程
  1. 扫描 `.cursor/rules/` 目录下的技术栈规则文件
  2. 验证规则文件与当前技术栈的匹配度
  3. 检查规则文件的版本和时效性
  4. 确认规则文件格式的有效性
  ```

- **智能规则应用**：
  - **精确匹配**：优先使用与当前技术栈版本完全匹配的规则
  - **向后兼容**：当精确版本不存在时，使用最近兼容版本
  - **降级处理**：规则文件缺失时，使用通用规则并提示生成专用规则
  - **冲突解决**：多个规则文件存在冲突时，按优先级自动选择

#### 2.2.2. 动态适应机制
- **实时版本检测**：在协作过程中持续监控技术栈变化
  ```markdown
  ## 变更检测触发点
  • package.json、requirements.txt 等配置文件修改
  • 新依赖安装或现有依赖升级
  • 构建工具配置变更 (webpack, vite, tsconfig 等)
  • 新技术栈引入 (如项目添加 TypeScript)
  ```

- **渐进式规则更新**：
  - **版本兼容性评估**：自动评估新版本与现有规则的兼容性
  - **增量规则生成**：仅为变更部分生成新规则，保留有效规则
  - **平滑过渡**：在新规则生成过程中，继续使用现有规则保证功能

- **语言特性**：遵循目标语言的编码规范和最佳实践，充分利用语言特有优势
- **框架规范**：项目使用特定框架时，优先遵循框架约定而非通用规则
- **依赖管理**：谨慎添加新依赖，确保与现有技术栈一致性

#### 2.2.3. 规则文件质量保证
- **自动验证机制**：
  - **语法检查**：验证规则文件的 Markdown 语法正确性
  - **内容完整性**：确保包含必要的规则和最佳实践
  - **实用性评估**：定期评估规则文件的使用频率和效果

- **版本管理策略**：
  ```markdown
  ## 规则文件版本管理
  • 为每个技术栈规则文件维护版本历史
  • 记录规则文件的生成时间和技术栈版本
  • 定期清理过期和无效的规则文件
  • 支持规则文件的回滚和恢复
  ```

### 2.3. 项目类型自适应
- **Web应用**: 前端框架、后端API、数据库设计规范
- **移动应用**: 响应式设计、原生开发、跨平台框架
- **桌面应用**: GUI框架、系统集成、用户体验
- **库/框架**: API设计、文档标准、版本管理
- **微服务**: 服务拆分、通信协议、监控部署
- **数据处理**: 算法优化、数据流程、可视化
- **AI/ML项目**: 模型训练、数据预处理、部署优化

### 2.4. 项目结构标准化

#### 2.4.1. 核心目录规范
- **统一目录结构**：所有项目必须遵循标准化的目录结构，确保项目间的一致性和可维护性
- **标准目录定义**：
  - **`logs/`**: 项目日志统一存放目录
    - 应用日志、错误日志、访问日志等分类存放
    - 支持日志轮转和自动清理机制，避免磁盘空间问题
    - 日志格式应统一，便于分析和监控
    - 重要问题的调试记录要归档到此目录
  - **`scripts/`**: 项目脚本统一存放目录
    - 按功能分类存放（deployment/, tools/, database/等）
    - 每个脚本必须有清晰的注释和使用说明
    - 包含系统检查工具和更新策略脚本
    - **核心子目录**：`deployment/`（部署脚本）、`tools/`（工具脚本）、`database/`（数据库脚本）
  - **`scripts.sh`**: 根目录交互式脚本入口 - **所有项目脚本的统一管理入口**
    - 提供交互式菜单选择所有可用脚本
    - 支持命令行参数直接调用特定脚本
    - 包含脚本使用帮助和状态检查功能
    - 确保在所有环境中都能正常运行
    - **部署管理功能**：环境切换、一键部署、全自动6步部署流程
  - **`backups/`**: 项目备份统一存放目录
    - 按时间和类型分类存放备份文件
    - 重要变更前必须提醒数据备份到此目录
    - 支持通过 scripts.sh 调用自动备份和恢复脚本
  - **`docs/`**: 项目文档统一存放目录
    - **文档分类**：架构文档/、开发指南/、部署运维/、API文档/、用户手册/、项目管理/、问题解决/、团队协作/
    - 支持多种文档格式（Markdown、PDF等）
    - 每个分类目录下必须有README.md说明用途和内容规范
    - **文档视觉元素使用规范**：
      - **表格使用场景**：数据对比、配置清单、功能矩阵、版本兼容性
      - **流程图使用场景**：业务流程、开发流程、决策树、用户路径
      - **架构图使用场景**：系统架构、模块关系、数据流向、技术栈展示
      - **时间线图使用场景**：项目计划、版本路线图、问题解决过程
      - **优先使用Mermaid语法**：便于版本控制和自动渲染
      - **视觉元素原则**：必要性优先、信息密度合理、移动端友好

#### 2.4.4. 文档视觉元素语法规范

**视觉元素选择原则**：
- **流程图**：超过5个步骤的操作流程、决策逻辑
- **架构图**：超过3个组件的系统设计、模块关系
- **表格**：超过3列的数据对比、配置清单、状态跟踪
- **甘特图**：超过1周的项目计划、时间安排
- **优先使用Mermaid语法**：便于版本控制和跨平台渲染

**文档质量标准**：
- **移动端友好**：表格列数≤3，图表节点文字≤6字，垂直布局优先
- **平台兼容**：确保GitHub、GitLab、Notion等平台正确渲染
- **可访问性**：图表提供文字描述，确保颜色对比度
- **结构清晰**：长文档（>500行）必须包含目录和锚点链接
- **版本控制**：重要文档注明更新时间和版本信息

#### 2.4.5. 目录使用和维护
- **目录结构验证**：定期验证项目目录结构的完整性和规范性
- **跨环境一致性**：
  - 确保开发、测试、生产环境的项目结构完全一致
  - 项目结构相关的配置要在所有环境中保持一致
- **注意**：目录的创建和初始化由 `project-initialization.mdc` 规则文件处理

#### 2.4.6. 使用规范和安全
- **路径引用规范**：
  - 代码中引用这些目录时使用相对路径
  - 配置文件中使用环境变量或配置项指定路径
  - 避免硬编码绝对路径，确保跨环境兼容性
- **权限和安全**：
  - logs/ 目录需要适当的读写权限
  - scripts/ 目录中的脚本需要执行权限
  - backups/ 目录需要严格的访问控制
  - docs/ 目录根据项目需要设置访问权限
- **维护和监控**：
  - 定期检查目录结构的完整性和规范性
  - 监控各目录的磁盘空间使用情况
  - 建立过期文件的自动清理机制

#### 2.4.7. 部署管理最佳实践
- **统一入口**：使用 scripts.sh 作为唯一部署入口，环境隔离和状态检查
- **自动化流程**：零交互部署、进度可视化、错误恢复、操作日志、安全验证
- **环境管理**：配置隔离、一键切换、状态持久化、安全提示

---

## 3. 协作交互规范

### 3.1. 协作标准概述
- **核心原则**：规则引用、中文交流、完整解决、上下文感知
- **决策边界**：立即执行、需确认、必须审查、禁止自主的智能判断
- **质量自适应**：根据环境类型和项目阶段调整质量要求

**📋 详细协作规范**：请参考 `collaboration-standards.mdc` 专用规则文件，包含：
- 回复格式规范和沟通标准  
- 智能决策边界的具体判断规则
- 质量标准自适应机制
- 错误处理和用户体验优化

### 3.2. 规则文件管理策略
- **问题驱动生成**：同一问题出现2次以上立即生成专用规则文件
- **技术栈规则应用**：自动应用项目初始化时生成的技术栈规则文件
- **智能修改机制**：规则失效、技术升级时自动触发更新
- **详细指南**：参考 `rule-file-management.mdc` 专用规则文件

---

## 4. 安全与质量保证

### 4.1. 安全优先原则
- **系统稳定性高于一切**：任何代码变更都不能以牺牲系统稳定性为代价
- **渐进式改进**：采用分离而非重构，新增而非替换，扩展而非修改的策略
- **可逆性保证**：所有变更都必须可以快速、安全地回滚到原始状态
- **敏感信息保护**：自动识别并保护API密钥、数据库凭据、用户隐私信息

### 4.2. 质量标准
- **代码可读性**：优先考虑代码的可读性和可维护性，而非简洁性
- **错误处理**：所有可能的错误情况都必须有适当的处理机制
- **测试覆盖**：新增代码要有相应的测试覆盖
- **文档同步**：代码变更时同步更新相关文档和注释
- **技术债务管理**：主动识别和管理技术债务，渐进式改进

### 4.3. 风险控制
- **小步快跑**：将大的变更拆分为多个小的、独立的、可验证的步骤
- **隔离变更**：新功能通过独立模块实现，避免影响核心业务逻辑
- **充分测试**：每个变更都必须经过完整的功能验证和回归测试
- **问题修复验证**：**任何问题修复后必须自主进行测试确保修复有效且没有引入新问题**
  - **修复验证测试**：重现原问题场景，确认问题已完全解决
  - **回归测试**：测试相关功能模块，确保修复没有影响其他功能
  - **边界测试**：测试修复涉及的边界条件和异常情况
  - **完整性验证**：确保修复后整体功能流程正常运行
  - **文档更新**：将测试结果和验证过程记录到 `logs/` 或 `docs/问题解决/` 目录
- **反复失败风险控制**：**当问题连续3次修复失败时，必须执行风险控制措施**（与第1.4节分层复盘机制联动）
  - **强制暂停策略**：连续3次修复失败后，强制暂停修复，自动启动深度复盘流程
  - **风险等级提升**：将问题风险等级从"常规"提升至"高风险"，采用更严格的变更控制
  - **影响范围重评估**：重新评估问题对整个系统的影响范围和潜在风险
  - **安全退路准备**：确保有可靠的回滚方案，必要时考虑临时绕过方案
  - **专家介入机制**：建议寻求外部专家意见或官方技术支持
  - **问题升级处理**：记录到 `docs/问题解决/高风险问题档案.md`，标记为需要特别关注的顽固问题
- **备份先行**：重要变更前自动提醒用户备份关键文件

---

## 5. 规则文件管理

### 5.1. 专用规则文件管理概述
- **核心原则**：自动生成、智能维护、质量保证、用户控制
- **分类体系**：一次性规则、技术栈规则、问题解决规则、运行时规则
- **优先级**：一次性规则 > 技术栈规则 > 安全规则 > 问题解决规则 > 功能域规则 > 通用规则

**📋 详细管理策略**：请参考 `rule-file-management.mdc` 专用规则文件，包含：
- 智能生命周期管理
- 版本管理策略
- 质量保证机制
- 规则文件分类与生成触发条件

### 5.2. 🚨 关键专用规则文件 (必须强制执行)

#### **Strapi字段描述强制配置 (strapi-field-descriptions.mdc)**
> **适用场景**: 新建任何Strapi内容类型时
- **⚠️ 致命错误级别**: 字段描述缺失 = 严重开发质量问题
- **强制要求**: 每个新内容类型必须配置中文字段描述
- **7步验证法**: 数据库注释 → 字段注释 → Strapi配置 → 脚本执行 → Admin验证 → 强制刷新 → 最终确认
- **自动化工具**: `./scripts/tools/configure-any-field-descriptions.sh [content-type]`
- **预防机制**: 开发启动检查 + 提交前强制验证 + 定期全量扫描
- **后果说明**: 管理员无法理解字段含义 → 数据录入错误 → 业务运营受影响

### 5.2. 维护策略
- **版本管理**：建立规则文件版本管理机制
- **定期更新**：根据项目发展和技术演进更新规则内容
- **效果评估**：定期评估规则文件的效果和实用性
- **清理机制**：定期清理过时或无效的规则文件

---

## 6. 项目管理与持续改进

### 6.1. 项目管理最佳实践
**📋 详细实践指南**：请参考 `project-management-practices.mdc` 专用规则文件，包含：
- **环境一致性管理**：开发、测试、生产环境标准化
- **监控与维护体系**：性能监控、日志管理、定期维护
- **团队协作规范**：代码协作、知识管理、问题反馈机制
- **质量保证机制**：多层质量检查和持续改进循环

### 6.2. 核心价值观
- **规则遵循优于开发便利**：严格遵循500行文件限制等核心规则，不得以开发便利为由违反
- **质量优于速度**：始终将代码质量和系统稳定性放在首位
- **安全优于便利**：在便利性和安全性之间，始终选择安全
- **团队协作优于个人效率**：代码要便于团队理解和维护
- **经验积累**：将每个项目的经验转化为可复用的知识