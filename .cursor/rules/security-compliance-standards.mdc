---
alwaysApply: intelligently
description: ä¼ä¸šçº§å®‰å…¨åˆè§„å¼€å‘ä¸“ç”¨è§„èŒƒï¼ŒåŒ…å«JWTè®¤è¯ã€æ•°æ®ä¿æŠ¤ã€å¨èƒæ£€æµ‹ã€éšç§åˆè§„ã€‚é€‚ç”¨äºå®‰å…¨è®¾è®¡ã€æ•°æ®ä¿æŠ¤ã€åˆè§„å®¡è®¡ç­‰åœºæ™¯ã€‚
triggerWords: ["security", "auth", "jwt", "password", "encryption", "privacy", "compliance", "threat", "vulnerability", "audit"]
---
## ğŸ›¡ï¸ æ•°æ®ä¿æŠ¤å¼ºåˆ¶è§„åˆ™ï¼ˆP0çº§ï¼‰

### 1. æ•æ„Ÿæ•°æ®å¤„ç†

#### æ•°æ®åˆ†ç±»ä¸ä¿æŠ¤ï¼ˆå¼ºåˆ¶æ ‡å‡†ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šæ•°æ®æ•æ„Ÿçº§åˆ«å®šä¹‰
export enum DataSensitivityLevel {
  PUBLIC = 'PUBLIC',           // å…¬å¼€æ•°æ®
  INTERNAL = 'INTERNAL',       // å†…éƒ¨æ•°æ®
  CONFIDENTIAL = 'CONFIDENTIAL', // æœºå¯†æ•°æ®
  RESTRICTED = 'RESTRICTED',   // é™åˆ¶çº§æ•°æ®
}

// âœ… å¼ºåˆ¶ï¼šå­—æ®µæ•æ„Ÿçº§åˆ«æ˜ å°„
export const FIELD_SENSITIVITY: Record<string, DataSensitivityLevel> = {
  // å…¬å¼€æ•°æ®
  id: DataSensitivityLevel.PUBLIC,
  username: DataSensitivityLevel.PUBLIC,
  display_name: DataSensitivityLevel.PUBLIC,
  avatar_url: DataSensitivityLevel.PUBLIC,
  bio: DataSensitivityLevel.PUBLIC,
  created_at: DataSensitivityLevel.PUBLIC,
  
  // å†…éƒ¨æ•°æ®
  email: DataSensitivityLevel.INTERNAL,
  location: DataSensitivityLevel.INTERNAL,
  last_login: DataSensitivityLevel.INTERNAL,
  
  // æœºå¯†æ•°æ®
  phone: DataSensitivityLevel.CONFIDENTIAL,
  real_name: DataSensitivityLevel.CONFIDENTIAL,
  id_number: DataSensitivityLevel.CONFIDENTIAL,
  
  // é™åˆ¶çº§æ•°æ®
  password_hash: DataSensitivityLevel.RESTRICTED,
  payment_info: DataSensitivityLevel.RESTRICTED,
  private_key: DataSensitivityLevel.RESTRICTED,
};

// âœ… å¼ºåˆ¶ï¼šæ•°æ®è„±æ•å¤„ç†
export class DataMaskingService {
  // âœ… å¼ºåˆ¶ï¼šæ ¹æ®æ•æ„Ÿçº§åˆ«è„±æ•
  static maskDataBySensitivity<T extends Record<string, any>>(
    data: T,
    userRole: string,
    requestingUserId?: string,
    dataOwnerId?: string
  ): Partial<T> {
    const result: Partial<T> = {};
    
    for (const [key, value] of Object.entries(data)) {
      const sensitivity = FIELD_SENSITIVITY[key] || DataSensitivityLevel.INTERNAL;
      
      // æ ¹æ®æƒé™å†³å®šæ˜¯å¦è¿”å›æ•°æ®
      if (this.canAccessField(sensitivity, userRole, requestingUserId, dataOwnerId)) {
        if (this.shouldMaskField(sensitivity, userRole, requestingUserId, dataOwnerId)) {
          result[key as keyof T] = this.maskValue(key, value);
        } else {
          result[key as keyof T] = value;
        }
      }
      // å¦‚æœæ— æƒé™è®¿é—®ï¼Œåˆ™ä¸åŒ…å«è¯¥å­—æ®µ
    }
    
    return result;
  }
  
  // âœ… å¼ºåˆ¶ï¼šæƒé™æ£€æŸ¥
  private static canAccessField(
    sensitivity: DataSensitivityLevel,
    userRole: string,
    requestingUserId?: string,
    dataOwnerId?: string
  ): boolean {
    // æ•°æ®æ‰€æœ‰è€…å¯ä»¥è®¿é—®è‡ªå·±çš„æ‰€æœ‰æ•°æ®
    if (requestingUserId === dataOwnerId) {
      return true;
    }
    
    // æ ¹æ®è§’è‰²å’Œæ•æ„Ÿçº§åˆ«åˆ¤æ–­
    switch (sensitivity) {
      case DataSensitivityLevel.PUBLIC:
        return true;
        
      case DataSensitivityLevel.INTERNAL:
        return ['user', 'moderator', 'admin', 'super_admin'].includes(userRole);
        
      case DataSensitivityLevel.CONFIDENTIAL:
        return ['admin', 'super_admin'].includes(userRole);
        
      case DataSensitivityLevel.RESTRICTED:
        return userRole === 'super_admin';
        
      default:
        return false;
    }
  }
  
  // âœ… å¼ºåˆ¶ï¼šæ˜¯å¦éœ€è¦è„±æ•
  private static shouldMaskField(
    sensitivity: DataSensitivityLevel,
    userRole: string,
    requestingUserId?: string,
    dataOwnerId?: string
  ): boolean {
    // æ•°æ®æ‰€æœ‰è€…çœ‹åˆ°å®Œæ•´æ•°æ®
    if (requestingUserId === dataOwnerId) {
      return false;
    }
    
    // è¶…çº§ç®¡ç†å‘˜çœ‹åˆ°å®Œæ•´æ•°æ®
    if (userRole === 'super_admin') {
      return false;
    }
    
    // å…¶ä»–æƒ…å†µæ ¹æ®æ•æ„Ÿçº§åˆ«å†³å®š
    return [DataSensitivityLevel.CONFIDENTIAL, DataSensitivityLevel.RESTRICTED].includes(sensitivity);
  }
  
  // âœ… å¼ºåˆ¶ï¼šå€¼è„±æ•å¤„ç†
  private static maskValue(fieldName: string, value: any): any {
    if (value == null) return value;
    
    switch (fieldName) {
      case 'email':
        return this.maskEmail(value);
      case 'phone':
        return this.maskPhone(value);
      case 'id_number':
        return this.maskIdNumber(value);
      case 'real_name':
        return this.maskName(value);
      default:
        return '***';
    }
  }
  
  private static maskEmail(email: string): string {
    const [local, domain] = email.split('@');
    if (local.length <= 2) return `${local}***@${domain}`;
    return `${local.substring(0, 2)}***@${domain}`;
  }
  
  private static maskPhone(phone: string): string {
    if (phone.length <= 4) return '***';
    return `${phone.substring(0, 3)}****${phone.substring(phone.length - 4)}`;
  }
  
  private static maskIdNumber(idNumber: string): string {
    if (idNumber.length <= 8) return '***';
    return `${idNumber.substring(0, 4)}****${idNumber.substring(idNumber.length - 4)}`;
  }
  
  private static maskName(name: string): string {
    if (name.length <= 1) return '*';
    return `${name.charAt(0)}${'*'.repeat(name.length - 1)}`;
  }
}
```

#### æ•°æ®åŠ å¯†å­˜å‚¨ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šæ•°æ®åŠ å¯†æœåŠ¡
export class EncryptionService {
  private readonly algorithm = 'aes-256-gcm';
  private readonly keyDerivationIterations = 100000;
  
  constructor(
    private readonly encryptionKey: string = process.env.ENCRYPTION_KEY!
  ) {
    if (!encryptionKey || encryptionKey.length < 32) {
      throw new Error('åŠ å¯†å¯†é’¥å¿…é¡»è‡³å°‘32å­—ç¬¦');
    }
  }
  
  // âœ… å¼ºåˆ¶ï¼šåŠ å¯†æ•æ„Ÿæ•°æ®
  async encryptSensitiveData(plaintext: string): Promise<string> {
    try {
      // ç”Ÿæˆéšæœºç›å’ŒIV
      const salt = crypto.randomBytes(32);
      const iv = crypto.randomBytes(16);
      
      // æ´¾ç”Ÿå¯†é’¥
      const key = crypto.pbkdf2Sync(
        this.encryptionKey, 
        salt, 
        this.keyDerivationIterations, 
        32, 
        'sha256'
      );
      
      // åˆ›å»ºåŠ å¯†å™¨
      const cipher = crypto.createCipher(this.algorithm, key);
      cipher.setAAD(salt); // é™„åŠ è®¤è¯æ•°æ®
      
      // åŠ å¯†æ•°æ®
      let encrypted = cipher.update(plaintext, 'utf8', 'hex');
      encrypted += cipher.final('hex');
      
      // è·å–è®¤è¯æ ‡ç­¾
      const authTag = cipher.getAuthTag();
      
      // ç»„åˆç»“æœï¼šsalt + iv + authTag + encrypted
      const result = Buffer.concat([
        salt,
        iv,
        authTag,
        Buffer.from(encrypted, 'hex')
      ]).toString('base64');
      
      return result;
    } catch (error) {
      logger.error('æ•°æ®åŠ å¯†å¤±è´¥', { error: error.message });
      throw new Error('æ•°æ®åŠ å¯†å¤±è´¥');
    }
  }
  
  // âœ… å¼ºåˆ¶ï¼šè§£å¯†æ•æ„Ÿæ•°æ®
  async decryptSensitiveData(encryptedData: string): Promise<string> {
    try {
      const buffer = Buffer.from(encryptedData, 'base64');
      
      // æå–ç»„ä»¶
      const salt = buffer.subarray(0, 32);
      const iv = buffer.subarray(32, 48);
      const authTag = buffer.subarray(48, 64);
      const encrypted = buffer.subarray(64);
      
      // æ´¾ç”Ÿå¯†é’¥
      const key = crypto.pbkdf2Sync(
        this.encryptionKey,
        salt,
        this.keyDerivationIterations,
        32,
        'sha256'
      );
      
      // åˆ›å»ºè§£å¯†å™¨
      const decipher = crypto.createDecipher(this.algorithm, key);
      decipher.setAAD(salt);
      decipher.setAuthTag(authTag);
      
      // è§£å¯†æ•°æ®
      let decrypted = decipher.update(encrypted, undefined, 'utf8');
      decrypted += decipher.final('utf8');
      
      return decrypted;
    } catch (error) {
      logger.error('æ•°æ®è§£å¯†å¤±è´¥', { error: error.message });
      throw new Error('æ•°æ®è§£å¯†å¤±è´¥');
    }
  }
  
  // âœ… å¼ºåˆ¶ï¼šå“ˆå¸Œæ•æ„Ÿæ•°æ®ï¼ˆä¸å¯é€†ï¼‰
  hashSensitiveData(data: string, salt?: string): string {
    const actualSalt = salt || crypto.randomBytes(16).toString('hex');
    const hash = crypto.pbkdf2Sync(data, actualSalt, this.keyDerivationIterations, 64, 'sha256');
    return `${actualSalt}:${hash.toString('hex')}`;
  }
  
  // âœ… å¼ºåˆ¶ï¼šéªŒè¯å“ˆå¸Œ
  verifyHashedData(data: string, hashedData: string): boolean {
    const [salt, hash] = hashedData.split(':');
    const dataHash = crypto.pbkdf2Sync(data, salt, this.keyDerivationIterations, 64, 'sha256');
    return dataHash.toString('hex') === hash;
  }
}

export const encryptionService = new EncryptionService();
```

### 2. APIå®‰å…¨é˜²æŠ¤

#### è¾“å…¥éªŒè¯ä¸æ¸…ç†ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šè¾“å…¥æ¸…ç†æœåŠ¡
export class InputSanitizationService {
  // âœ… å¼ºåˆ¶ï¼šXSSé˜²æŠ¤
  static sanitizeHTML(input: string): string {
    if (!input) return '';
    
    // ç§»é™¤å±é™©æ ‡ç­¾å’Œå±æ€§
    return input
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi, '')
      .replace(/<object\b[^<]*(?:(?!<\/object>)<[^<]*)*<\/object>/gi, '')
      .replace(/<embed\b[^<]*(?:(?!<\/embed>)<[^<]*)*<\/embed>/gi, '')
      .replace(/javascript:/gi, '')
      .replace(/on\w+\s*=/gi, '')
      .replace(/style\s*=/gi, '');
  }
  
  // âœ… å¼ºåˆ¶ï¼šSQLæ³¨å…¥é˜²æŠ¤
  static sanitizeSQL(input: string): string {
    if (!input) return '';
    
    // è½¬ä¹‰å±é™©å­—ç¬¦
    return input
      .replace(/'/g, "''")
      .replace(/;/g, '\\;')
      .replace(/--/g, '\\--')
      .replace(/\/\*/g, '\\/\\*')
      .replace(/\*\//g, '\\*\\/')
      .replace(/xp_/gi, 'x_p_')
      .replace(/sp_/gi, 's_p_');
  }
  
  // âœ… å¼ºåˆ¶ï¼šå‘½ä»¤æ³¨å…¥é˜²æŠ¤
  static sanitizeCommand(input: string): string {
    if (!input) return '';
    
    // ç§»é™¤å±é™©å­—ç¬¦
    return input
      .replace(/[;&|`$(){}[\]]/g, '')
      .replace(/\n/g, '')
      .replace(/\r/g, '');
  }
  
  // âœ… å¼ºåˆ¶ï¼šè·¯å¾„éå†é˜²æŠ¤
  static sanitizePath(path: string): string {
    if (!path) return '';
    
    return path
      .replace(/\.\./g, '')
      .replace(/[<>:"|?*]/g, '')
      .replace(/^\//g, '')
      .replace(/\/$/, '');
  }
  
  // âœ… å¼ºåˆ¶ï¼šç»¼åˆè¾“å…¥æ¸…ç†
  static sanitizeInput(input: any, type: 'html' | 'sql' | 'command' | 'path' | 'general'): any {
    if (input === null || input === undefined) return input;
    
    if (typeof input === 'string') {
      switch (type) {
        case 'html':
          return this.sanitizeHTML(input);
        case 'sql':
          return this.sanitizeSQL(input);
        case 'command':
          return this.sanitizeCommand(input);
        case 'path':
          return this.sanitizePath(input);
        case 'general':
        default:
          return this.sanitizeHTML(input);
      }
    }
    
    if (Array.isArray(input)) {
      return input.map(item => this.sanitizeInput(item, type));
    }
    
    if (typeof input === 'object') {
      const sanitized: any = {};
      for (const [key, value] of Object.entries(input)) {
        sanitized[key] = this.sanitizeInput(value, type);
      }
      return sanitized;
    }
    
    return input;
  }
}

// âœ… å¼ºåˆ¶ï¼šè¾“å…¥æ¸…ç†ä¸­é—´ä»¶
export const inputSanitization = (type: 'html' | 'sql' | 'command' | 'path' | 'general' = 'general') => {
  return (req: Request, res: Response, next: NextFunction) => {
    // æ¸…ç†è¯·æ±‚ä½“
    if (req.body) {
      req.body = InputSanitizationService.sanitizeInput(req.body, type);
    }
    
    // æ¸…ç†æŸ¥è¯¢å‚æ•°
    if (req.query) {
      req.query = InputSanitizationService.sanitizeInput(req.query, type);
    }
    
    // æ¸…ç†è·¯å¾„å‚æ•°
    if (req.params) {
      req.params = InputSanitizationService.sanitizeInput(req.params, type);
    }
    
    next();
  };
};
```

#### CSRFå’ŒCORSå®‰å…¨ï¼ˆå¼ºåˆ¶é…ç½®ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šCSRFä¿æŠ¤é…ç½®
export const csrfProtection = csrf({
  cookie: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 3600000, // 1å°æ—¶
  },
  ignoreMethods: ['GET', 'HEAD', 'OPTIONS'],
  value: (req) => {
    // ä»headeræˆ–bodyä¸­è·å–CSRF token
    return req.get('X-CSRF-Token') || 
           req.get('X-Requested-With') || 
           req.body._csrf;
  },
});

// âœ… å¼ºåˆ¶ï¼šCORSå®‰å…¨é…ç½®
export const corsOptions: CorsOptions = {
  origin: (origin, callback) => {
    const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || [];
    
    // å¼€å‘ç¯å¢ƒå…è®¸localhost
    if (process.env.NODE_ENV === 'development') {
      allowedOrigins.push('http://localhost:5173', 'http://localhost:3000');
    }
    
    // å…è®¸æ— originçš„è¯·æ±‚ï¼ˆå¦‚ç§»åŠ¨åº”ç”¨ï¼‰
    if (!origin) return callback(null, true);
    
    if (allowedOrigins.includes(origin)) {
      return callback(null, true);
    } else {
      logger.warn('CORSé˜»æ­¢çš„è¯·æ±‚', { origin, allowedOrigins });
      return callback(new Error('CORSç­–ç•¥ä¸å…è®¸æ­¤æ¥æº'));
    }
  },
  
  credentials: true,
  
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  
  allowedHeaders: [
    'Content-Type',
    'Authorization',
    'X-Requested-With',
    'X-CSRF-Token',
  ],
  
  exposedHeaders: ['X-CSRF-Token'],
  
  maxAge: 86400, // 24å°æ—¶
  
  preflightContinue: false,
  optionsSuccessStatus: 200,
};
```

---

## ğŸš¨ å®‰å…¨ç›‘æ§å¼ºåˆ¶è§„åˆ™ï¼ˆP0çº§ï¼‰

### 1. å®‰å…¨äº‹ä»¶ç›‘æ§

#### å®‰å…¨æ—¥å¿—è®°å½•ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šå®‰å…¨äº‹ä»¶ç±»å‹å®šä¹‰
export enum SecurityEventType {
  // è®¤è¯äº‹ä»¶
  LOGIN_SUCCESS = 'LOGIN_SUCCESS',
  LOGIN_FAILURE = 'LOGIN_FAILURE',
  LOGIN_BLOCKED = 'LOGIN_BLOCKED',
  LOGOUT = 'LOGOUT',
  TOKEN_REFRESH = 'TOKEN_REFRESH',
  TOKEN_EXPIRED = 'TOKEN_EXPIRED',
  
  // æˆæƒäº‹ä»¶
  ACCESS_DENIED = 'ACCESS_DENIED',
  PRIVILEGE_ESCALATION = 'PRIVILEGE_ESCALATION',
  UNAUTHORIZED_ACCESS = 'UNAUTHORIZED_ACCESS',
  
  // æ•°æ®äº‹ä»¶
  DATA_ACCESS = 'DATA_ACCESS',
  DATA_MODIFICATION = 'DATA_MODIFICATION',
  DATA_DELETION = 'DATA_DELETION',
  SENSITIVE_DATA_ACCESS = 'SENSITIVE_DATA_ACCESS',
  
  // æ”»å‡»äº‹ä»¶
  SQL_INJECTION_ATTEMPT = 'SQL_INJECTION_ATTEMPT',
  XSS_ATTEMPT = 'XSS_ATTEMPT',
  CSRF_ATTEMPT = 'CSRF_ATTEMPT',
  BRUTE_FORCE_ATTACK = 'BRUTE_FORCE_ATTACK',
  
  // ç³»ç»Ÿäº‹ä»¶
  SYSTEM_CONFIGURATION_CHANGE = 'SYSTEM_CONFIGURATION_CHANGE',
  ADMIN_ACTION = 'ADMIN_ACTION',
  SUSPICIOUS_ACTIVITY = 'SUSPICIOUS_ACTIVITY',
}

// âœ… å¼ºåˆ¶ï¼šå®‰å…¨äº‹ä»¶è®°å½•æœåŠ¡
export class SecurityAuditService {
  private static instance: SecurityAuditService;
  
  static getInstance(): SecurityAuditService {
    if (!SecurityAuditService.instance) {
      SecurityAuditService.instance = new SecurityAuditService();
    }
    return SecurityAuditService.instance;
  }
  
  // âœ… å¼ºåˆ¶ï¼šè®°å½•å®‰å…¨äº‹ä»¶
  async logSecurityEvent(event: {
    type: SecurityEventType;
    userId?: string;
    ip: string;
    userAgent: string;
    resource?: string;
    action?: string;
    result: 'SUCCESS' | 'FAILURE' | 'BLOCKED';
    details?: Record<string, any>;
    riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  }): Promise<void> {
    const securityLog = {
      ...event,
      timestamp: new Date().toISOString(),
      id: crypto.randomUUID(),
    };
    
    // âœ… å¼ºåˆ¶ï¼šå†™å…¥å®‰å…¨æ—¥å¿—æ•°æ®åº“
    await this.writeToSecurityLog(securityLog);
    
    // âœ… å¼ºåˆ¶ï¼šé«˜é£é™©äº‹ä»¶å®æ—¶å‘Šè­¦
    if (event.riskLevel === 'CRITICAL' || event.riskLevel === 'HIGH') {
      await this.sendSecurityAlert(securityLog);
    }
    
    // âœ… å¼ºåˆ¶ï¼šç»“æ„åŒ–æ—¥å¿—è®°å½•
    logger.info('å®‰å…¨äº‹ä»¶', securityLog);
  }
  
  private async writeToSecurityLog(log: any): Promise<void> {
    try {
      const { error } = await supabase
        .from('security_logs')
        .insert(log);
      
      if (error) {
        logger.error('å®‰å…¨æ—¥å¿—å†™å…¥å¤±è´¥', { error: error.message, log });
      }
    } catch (error) {
      logger.error('å®‰å…¨æ—¥å¿—ç³»ç»Ÿå¼‚å¸¸', { error, log });
    }
  }
  
  private async sendSecurityAlert(log: any): Promise<void> {
    try {
      // å‘é€åˆ°å®‰å…¨å›¢é˜Ÿ
      await fetch(process.env.SECURITY_WEBHOOK_URL!, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          text: `ğŸš¨ å®‰å…¨å‘Šè­¦: ${log.type}`,
          attachments: [{
            color: log.riskLevel === 'CRITICAL' ? 'danger' : 'warning',
            fields: [
              { title: 'äº‹ä»¶ç±»å‹', value: log.type, short: true },
              { title: 'é£é™©çº§åˆ«', value: log.riskLevel, short: true },
              { title: 'ç”¨æˆ·ID', value: log.userId || 'Unknown', short: true },
              { title: 'IPåœ°å€', value: log.ip, short: true },
              { title: 'æ—¶é—´', value: log.timestamp, short: false },
              { title: 'è¯¦æƒ…', value: JSON.stringify(log.details), short: false },
            ]
          }]
        })
      });
    } catch (error) {
      logger.error('å®‰å…¨å‘Šè­¦å‘é€å¤±è´¥', { error });
    }
  }
  
  // âœ… å¼ºåˆ¶ï¼šå¼‚å¸¸è¡Œä¸ºæ£€æµ‹
  async detectAnomalousActivity(userId: string, activity: {
    type: string;
    ip: string;
    userAgent: string;
    timestamp: number;
  }): Promise<{
    isAnomalous: boolean;
    riskScore: number;
    reasons: string[];
  }> {
    const reasons: string[] = [];
    let riskScore = 0;
    
    // æ£€æŸ¥IPåœ°å€å˜åŒ–
    const recentIPs = await this.getUserRecentIPs(userId, 24 * 60 * 60 * 1000); // 24å°æ—¶
    if (recentIPs.length > 0 && !recentIPs.includes(activity.ip)) {
      riskScore += 30;
      reasons.push('æ¥è‡ªæ–°çš„IPåœ°å€');
    }
    
    // æ£€æŸ¥ç”¨æˆ·ä»£ç†å˜åŒ–
    const recentUserAgents = await this.getUserRecentUserAgents(userId, 24 * 60 * 60 * 1000);
    if (recentUserAgents.length > 0 && !recentUserAgents.includes(activity.userAgent)) {
      riskScore += 20;
      reasons.push('ä½¿ç”¨æ–°çš„è®¾å¤‡æˆ–æµè§ˆå™¨');
    }
    
    // æ£€æŸ¥æ´»åŠ¨é¢‘ç‡
    const recentActivityCount = await this.getUserRecentActivityCount(userId, 60 * 60 * 1000); // 1å°æ—¶
    if (recentActivityCount > 100) {
      riskScore += 40;
      reasons.push('æ´»åŠ¨é¢‘ç‡å¼‚å¸¸é«˜');
    }
    
    // æ£€æŸ¥å¼‚å¸¸æ—¶é—´
    const hour = new Date().getHours();
    if (hour < 6 || hour > 23) { // å‡Œæ™¨æ´»åŠ¨
      riskScore += 10;
      reasons.push('åœ¨å¼‚å¸¸æ—¶é—´æ´»åŠ¨');
    }
    
    return {
      isAnomalous: riskScore >= 50,
      riskScore,
      reasons,
    };
  }
  
  private async getUserRecentIPs(userId: string, timeWindow: number): Promise<string[]> {
    const since = new Date(Date.now() - timeWindow).toISOString();
    
    const { data, error } = await supabase
      .from('security_logs')
      .select('ip')
      .eq('user_id', userId)
      .gte('timestamp', since)
      .limit(10);
    
    if (error) return [];
    
    return [...new Set(data.map(log => log.ip))];
  }
  
  private async getUserRecentUserAgents(userId: string, timeWindow: number): Promise<string[]> {
    const since = new Date(Date.now() - timeWindow).toISOString();
    
    const { data, error } = await supabase
      .from('security_logs')
      .select('user_agent')
      .eq('user_id', userId)
      .gte('timestamp', since)
      .limit(10);
    
    if (error) return [];
    
    return [...new Set(data.map(log => log.user_agent))];
  }
  
  private async getUserRecentActivityCount(userId: string, timeWindow: number): Promise<number> {
    const since = new Date(Date.now() - timeWindow).toISOString();
    
    const { count, error } = await supabase
      .from('security_logs')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId)
      .gte('timestamp', since);
    
    if (error) return 0;
    
    return count || 0;
  }
}

export const securityAudit = SecurityAuditService.getInstance();
```

### 2. å¨èƒæ£€æµ‹ä¸å“åº”

#### å®æ—¶å¨èƒæ£€æµ‹ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šå¨èƒæ£€æµ‹ä¸­é—´ä»¶
export const threatDetectionMiddleware = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const ip = req.ip;
    const userAgent = req.get('user-agent') || '';
    const userId = (req as any).user?.id;
    
    // âœ… å¼ºåˆ¶ï¼šæ£€æµ‹SQLæ³¨å…¥å°è¯•
    const sqlInjectionDetected = detectSQLInjection(req);
    if (sqlInjectionDetected) {
      await securityAudit.logSecurityEvent({
        type: SecurityEventType.SQL_INJECTION_ATTEMPT,
        userId,
        ip,
        userAgent,
        resource: req.path,
        action: req.method,
        result: 'BLOCKED',
        details: { 
          suspiciousParams: sqlInjectionDetected.suspiciousParams,
          detectedPatterns: sqlInjectionDetected.patterns 
        },
        riskLevel: 'HIGH',
      });
      
      return res.status(400).json({
        success: false,
        error: { code: 'SECURITY_VIOLATION' },
        message: 'æ£€æµ‹åˆ°å¯ç–‘è¯·æ±‚'
      });
    }
    
    // âœ… å¼ºåˆ¶ï¼šæ£€æµ‹XSSå°è¯•
    const xssDetected = detectXSS(req);
    if (xssDetected) {
      await securityAudit.logSecurityEvent({
        type: SecurityEventType.XSS_ATTEMPT,
        userId,
        ip,
        userAgent,
        resource: req.path,
        action: req.method,
        result: 'BLOCKED',
        details: { 
          suspiciousContent: xssDetected.suspiciousContent,
          detectedTags: xssDetected.tags 
        },
        riskLevel: 'HIGH',
      });
      
      return res.status(400).json({
        success: false,
        error: { code: 'SECURITY_VIOLATION' },
        message: 'æ£€æµ‹åˆ°å¯ç–‘å†…å®¹'
      });
    }
    
    // âœ… å¼ºåˆ¶ï¼šæ£€æµ‹å¼‚å¸¸è¡Œä¸º
    if (userId) {
      const anomalyResult = await securityAudit.detectAnomalousActivity(userId, {
        type: req.method,
        ip,
        userAgent,
        timestamp: Date.now(),
      });
      
      if (anomalyResult.isAnomalous) {
        await securityAudit.logSecurityEvent({
          type: SecurityEventType.SUSPICIOUS_ACTIVITY,
          userId,
          ip,
          userAgent,
          resource: req.path,
          action: req.method,
          result: 'SUCCESS',
          details: {
            riskScore: anomalyResult.riskScore,
            reasons: anomalyResult.reasons,
          },
          riskLevel: anomalyResult.riskScore > 70 ? 'HIGH' : 'MEDIUM',
        });
      }
    }
    
    next();
  } catch (error) {
    logger.error('å¨èƒæ£€æµ‹ä¸­é—´ä»¶å¼‚å¸¸', { error });
    next(); // ä¸é˜»æ­¢æ­£å¸¸è¯·æ±‚
  }
};

// âœ… å¼ºåˆ¶ï¼šSQLæ³¨å…¥æ£€æµ‹
function detectSQLInjection(req: Request): {
  suspiciousParams: string[];
  patterns: string[];
} | null {
  const sqlPatterns = [
    /('|(\\\')|(\-\-)|(;)|(\|)|(\*)|(%7c))/i,
    /(union|select|insert|delete|update|drop|create|alter|exec|execute)/i,
    /(script|javascript|vbscript|onload|onerror|onclick)/i,
  ];
  
  const suspiciousParams: string[] = [];
  const detectedPatterns: string[] = [];
  
  const checkValue = (value: string, paramName: string) => {
    for (const pattern of sqlPatterns) {
      if (pattern.test(value)) {
        suspiciousParams.push(paramName);
        detectedPatterns.push(pattern.source);
      }
    }
  };
  
  // æ£€æŸ¥æŸ¥è¯¢å‚æ•°
  for (const [key, value] of Object.entries(req.query)) {
    if (typeof value === 'string') {
      checkValue(value, `query.${key}`);
    }
  }
  
  // æ£€æŸ¥è¯·æ±‚ä½“
  const checkObject = (obj: any, prefix: string) => {
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === 'string') {
        checkValue(value, `${prefix}.${key}`);
      } else if (typeof value === 'object' && value !== null) {
        checkObject(value, `${prefix}.${key}`);
      }
    }
  };
  
  if (req.body && typeof req.body === 'object') {
    checkObject(req.body, 'body');
  }
  
  return suspiciousParams.length > 0 ? { suspiciousParams, patterns: detectedPatterns } : null;
}

// âœ… å¼ºåˆ¶ï¼šXSSæ£€æµ‹
function detectXSS(req: Request): {
  suspiciousContent: string[];
  tags: string[];
} | null {
  const xssPatterns = [
    /<script[\s\S]*?>[\s\S]*?<\/script>/i,
    /<iframe[\s\S]*?>[\s\S]*?<\/iframe>/i,
    /javascript:/i,
    /on\w+\s*=/i,
    /<img[\s\S]*?src[\s\S]*?javascript:/i,
  ];
  
  const suspiciousContent: string[] = [];
  const detectedTags: string[] = [];
  
  const checkValue = (value: string, location: string) => {
    for (const pattern of xssPatterns) {
      if (pattern.test(value)) {
        suspiciousContent.push(location);
        detectedTags.push(pattern.source);
      }
    }
  };
  
  // æ£€æŸ¥æ‰€æœ‰å­—ç¬¦ä¸²å€¼
  const checkObject = (obj: any, prefix: string) => {
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === 'string') {
        checkValue(value, `${prefix}.${key}`);
      } else if (typeof value === 'object' && value !== null) {
        checkObject(value, `${prefix}.${key}`);
      }
    }
  };
  
  if (req.body && typeof req.body === 'object') {
    checkObject(req.body, 'body');
  }
  
  for (const [key, value] of Object.entries(req.query)) {
    if (typeof value === 'string') {
      checkValue(value, `query.${key}`);
    }
  }
  
  return suspiciousContent.length > 0 ? { suspiciousContent, tags: detectedTags } : null;
}
```

---

## ğŸ“‹ å®‰å…¨åˆè§„æ£€æŸ¥æ¸…å•

### å¼€å‘é˜¶æ®µå®‰å…¨æ£€æŸ¥

#### è®¤è¯ä¸æˆæƒ
- [ ] **JWTé…ç½®**: ä½¿ç”¨å¼ºå¯†é’¥ã€åˆç†è¿‡æœŸæ—¶é—´ã€å®‰å…¨ç®—æ³•
- [ ] **å¯†ç ç­–ç•¥**: ç¬¦åˆå¤æ‚åº¦è¦æ±‚ã€å®‰å…¨å“ˆå¸Œå­˜å‚¨
- [ ] **ç™»å½•ä¿æŠ¤**: å®ç°è´¦æˆ·é”å®šã€IPé™åˆ¶ã€å¼‚å¸¸æ£€æµ‹
- [ ] **æƒé™æ§åˆ¶**: RBACå®ç°ã€æœ€å°æƒé™åŸåˆ™
- [ ] **ä¼šè¯ç®¡ç†**: å®‰å…¨çš„ä¼šè¯åˆ›å»ºã€åˆ·æ–°ã€é”€æ¯

#### æ•°æ®ä¿æŠ¤
- [ ] **æ•°æ®åˆ†ç±»**: æ•æ„Ÿæ•°æ®æ­£ç¡®åˆ†ç±»å’Œæ ‡è®°
- [ ] **åŠ å¯†å­˜å‚¨**: æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨
- [ ] **æ•°æ®è„±æ•**: æ ¹æ®æƒé™æ­£ç¡®è„±æ•
- [ ] **ä¼ è¾“åŠ å¯†**: ä½¿ç”¨HTTPS/TLS
- [ ] **è®¿é—®æ§åˆ¶**: æ•°æ®è®¿é—®æƒé™æ­£ç¡®å®ç°

#### è¾“å…¥éªŒè¯
- [ ] **XSSé˜²æŠ¤**: ç”¨æˆ·è¾“å…¥æ­£ç¡®è¿‡æ»¤å’Œè½¬ä¹‰
- [ ] **SQLæ³¨å…¥**: ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
- [ ] **CSRFä¿æŠ¤**: å®ç°CSRF tokenéªŒè¯
- [ ] **è¾“å…¥æ¸…ç†**: å±é™©å­—ç¬¦æ­£ç¡®å¤„ç†
- [ ] **æ–‡ä»¶ä¸Šä¼ **: æ–‡ä»¶ç±»å‹å’Œå¤§å°é™åˆ¶

### å‘å¸ƒå‰å®‰å…¨æ£€æŸ¥

#### å®‰å…¨é…ç½®
- [ ] **ç¯å¢ƒå˜é‡**: æ•æ„Ÿä¿¡æ¯ä¸åœ¨ä»£ç ä¸­ç¡¬ç¼–ç 
- [ ] **CORSé…ç½®**: æ­£ç¡®é…ç½®å…è®¸çš„åŸŸå
- [ ] **å®‰å…¨å¤´**: è®¾ç½®é€‚å½“çš„å®‰å…¨HTTPå¤´
- [ ] **é”™è¯¯å¤„ç†**: ä¸æ³„éœ²æ•æ„Ÿä¿¡æ¯çš„é”™è¯¯æ¶ˆæ¯
- [ ] **æ—¥å¿—å®‰å…¨**: æ•æ„Ÿä¿¡æ¯ä¸è®°å½•åœ¨æ—¥å¿—ä¸­

#### ç›‘æ§å‘Šè­¦
- [ ] **å®‰å…¨æ—¥å¿—**: å®Œæ•´çš„å®‰å…¨äº‹ä»¶è®°å½•
- [ ] **å¼‚å¸¸æ£€æµ‹**: å®æ—¶æ£€æµ‹å¯ç–‘æ´»åŠ¨
- [ ] **å‘Šè­¦æœºåˆ¶**: å®‰å…¨äº‹ä»¶åŠæ—¶é€šçŸ¥
- [ ] **å®¡è®¡è¿½è¸ª**: é‡è¦æ“ä½œå¯è¿½æº¯
- [ ] **å¨èƒæ£€æµ‹**: è‡ªåŠ¨åŒ–å¨èƒæ£€æµ‹å’Œå“åº”

#### åˆè§„æ€§æ£€æŸ¥
- [ ] **æ•°æ®éšç§**: ç¬¦åˆGDPR/CCPAè¦æ±‚
- [ ] **ç”¨æˆ·åŒæ„**: éšç§æ”¿ç­–å’Œç”¨æˆ·åè®®
- [ ] **æ•°æ®ç•™å­˜**: åˆç†çš„æ•°æ®ä¿ç•™ç­–ç•¥
- [ ] **åˆ é™¤æƒ**: ç”¨æˆ·æ•°æ®åˆ é™¤åŠŸèƒ½
- [ ] **é€æ˜åº¦**: æ•°æ®ä½¿ç”¨é€æ˜åŒ–

---

**é€‚ç”¨é¡¹ç›®**: BiuBiuStarç¤¾äº¤å¹³å°å®‰å…¨åˆè§„  
**æ›´æ–°é¢‘ç‡**: å®‰å…¨å¨èƒå˜åŒ–æ—¶åŠæ—¶æ›´æ–°  
**å¼ºåˆ¶æ‰§è¡Œ**: æ‰€æœ‰P0çº§è§„åˆ™å¿…é¡»100%éµå¾ªï¼Œå…³é”®å®‰å…¨æ§åˆ¶ä¸å¾—å¦¥å