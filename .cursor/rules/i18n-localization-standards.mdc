---
alwaysApply: intelligently
description: å›½é™…åŒ–ä¸æœ¬åœ°åŒ–å¼€å‘ä¸“ç”¨è§„èŒƒï¼ŒåŒ…å«å¤šè¯­è¨€æ”¯æŒã€æ–‡æœ¬ç¿»è¯‘ã€åœ°åŒºé€‚é…ã€RTLæ”¯æŒã€‚é€‚ç”¨äºå¤šè¯­è¨€åº”ç”¨ã€æœ¬åœ°åŒ–å¼€å‘ã€å›½é™…åŒ–æ”¹é€ ç­‰åœºæ™¯ã€‚
triggerWords: ["i18n", "internationalization", "localization", "translation", "language", "locale", "multilingual", "rtl", "timezone", "currency"]
---

# å›½é™…åŒ–ä¸æœ¬åœ°åŒ–å¼€å‘è§„èŒƒ

> **å›½é™…åŒ–æ¡†æ¶**: i18next + react-i18next + å¤šè¯­è¨€æ”¯æŒ  
> **é€‚ç”¨é¡¹ç›®**: BiuBiuStarç¤¾äº¤å¹³å° - å…¨çƒåŒ–å¤šè¯­è¨€åº”ç”¨

---

## ğŸ”¥ å›½é™…åŒ–æ¶æ„å¼ºåˆ¶è§„åˆ™ï¼ˆP0çº§ï¼‰

### 1. i18nexté…ç½®æ ‡å‡†

#### æ ¸å¿ƒé…ç½®ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// src/i18n/index.ts - å¼ºåˆ¶i18né…ç½®æ ‡å‡†
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import LanguageDetector from 'i18next-browser-languagedetector';

// âœ… å¼ºåˆ¶ï¼šæ”¯æŒçš„è¯­è¨€åˆ—è¡¨
export const SUPPORTED_LANGUAGES = {
  'zh': {
    code: 'zh',
    name: 'ç®€ä½“ä¸­æ–‡',
    nativeName: 'ç®€ä½“ä¸­æ–‡',
    flag: 'ğŸ‡¨ğŸ‡³',
    direction: 'ltr' as const,
  },
  'zh-TW': {
    code: 'zh-TW', 
    name: 'ç¹é«”ä¸­æ–‡',
    nativeName: 'ç¹é«”ä¸­æ–‡',
    flag: 'ğŸ‡¹ğŸ‡¼',
    direction: 'ltr' as const,
  },
  'en': {
    code: 'en',
    name: 'English',
    nativeName: 'English', 
    flag: 'ğŸ‡ºğŸ‡¸',
    direction: 'ltr' as const,
  },
  'ja': {
    code: 'ja',
    name: 'æ—¥æœ¬èª',
    nativeName: 'æ—¥æœ¬èª',
    flag: 'ğŸ‡¯ğŸ‡µ',
    direction: 'ltr' as const,
  },
  'ko': {
    code: 'ko',
    name: 'í•œêµ­ì–´',
    nativeName: 'í•œêµ­ì–´',
    flag: 'ğŸ‡°ğŸ‡·',
    direction: 'ltr' as const,
  },
  'vi': {
    code: 'vi',
    name: 'Tiáº¿ng Viá»‡t',
    nativeName: 'Tiáº¿ng Viá»‡t',
    flag: 'ğŸ‡»ğŸ‡³',
    direction: 'ltr' as const,
  }
} as const;

export type SupportedLanguage = keyof typeof SUPPORTED_LANGUAGES;

// âœ… å¼ºåˆ¶ï¼ši18nåˆå§‹åŒ–é…ç½®
i18n
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    // âœ… å¼ºåˆ¶ï¼šåŸºç¡€é…ç½®
    fallbackLng: 'zh',
    defaultNS: 'common',
    debug: process.env.NODE_ENV === 'development',
    
    // âœ… å¼ºåˆ¶ï¼šè¯­è¨€æ£€æµ‹é…ç½®
    detection: {
      order: ['localStorage', 'navigator', 'htmlTag'],
      caches: ['localStorage'],
      lookupLocalStorage: 'i18nextLng',
    },
    
    // âœ… å¼ºåˆ¶ï¼šæ’å€¼é…ç½®
    interpolation: {
      escapeValue: false, // Reactå·²ç»é˜²XSS
      formatSeparator: ',',
      format: (value, format, lng) => {
        // æ•°å­—æ ¼å¼åŒ–
        if (format === 'number') {
          return new Intl.NumberFormat(lng).format(value);
        }
        
        // è´§å¸æ ¼å¼åŒ–
        if (format?.startsWith('currency')) {
          const currency = format.split(':')[1] || 'USD';
          return new Intl.NumberFormat(lng, {
            style: 'currency',
            currency: currency.toUpperCase(),
          }).format(value);
        }
        
        // æ—¥æœŸæ ¼å¼åŒ–
        if (format === 'date') {
          return new Intl.DateTimeFormat(lng).format(new Date(value));
        }
        
        if (format === 'datetime') {
          return new Intl.DateTimeFormat(lng, {
            year: 'numeric',
            month: 'short', 
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
          }).format(new Date(value));
        }
        
        return value;
      },
    },
    
    // âœ… å¼ºåˆ¶ï¼šèµ„æºé…ç½®
    resources: {
      zh: {
        common: () => import('../locales/zh.json'),
        auth: () => import('../locales/zh/auth.json'),
        posts: () => import('../locales/zh/posts.json'),
        settings: () => import('../locales/zh/settings.json'),
      },
      'zh-TW': {
        common: () => import('../locales/zh-tw.json'),
        auth: () => import('../locales/zh-tw/auth.json'),
        posts: () => import('../locales/zh-tw/posts.json'),
        settings: () => import('../locales/zh-tw/settings.json'),
      },
      en: {
        common: () => import('../locales/en.json'),
        auth: () => import('../locales/en/auth.json'),
        posts: () => import('../locales/en/posts.json'),
        settings: () => import('../locales/en/settings.json'),
      },
      // å…¶ä»–è¯­è¨€...
    },
    
    // âœ… å¼ºåˆ¶ï¼šReacté…ç½®
    react: {
      useSuspense: true,
      bindI18n: 'languageChanged',
      bindI18nStore: '',
      transEmptyNodeValue: '',
      transSupportBasicHtmlNodes: true,
      transKeepBasicHtmlNodesFor: ['br', 'strong', 'i', 'em'],
    },
  });

export default i18n;
```

#### å‘½åç©ºé—´ç»„ç»‡ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šç¿»è¯‘å‘½åç©ºé—´ç»“æ„
export const I18N_NAMESPACES = {
  // é€šç”¨å‘½åç©ºé—´
  common: 'common',           // é€šç”¨æ–‡æœ¬ã€æŒ‰é’®ã€æ ‡ç­¾
  navigation: 'navigation',   // å¯¼èˆªèœå•ã€é¢åŒ…å±‘
  errors: 'errors',          // é”™è¯¯ä¿¡æ¯ã€éªŒè¯æ¶ˆæ¯
  
  // åŠŸèƒ½å‘½åç©ºé—´
  auth: 'auth',              // è®¤è¯ç›¸å…³ï¼šç™»å½•ã€æ³¨å†Œ
  posts: 'posts',            // å¸–å­ç›¸å…³ï¼šåˆ›å»ºã€ç¼–è¾‘
  users: 'users',            // ç”¨æˆ·ç›¸å…³ï¼šèµ„æ–™ã€è®¾ç½®
  notifications: 'notifications', // é€šçŸ¥æ¶ˆæ¯
  settings: 'settings',      // ç³»ç»Ÿè®¾ç½®
  admin: 'admin',            // ç®¡ç†åŠŸèƒ½
  
  // é¡µé¢å‘½åç©ºé—´
  home: 'home',              // é¦–é¡µå†…å®¹
  profile: 'profile',        // ä¸ªäººèµ„æ–™é¡µ
  search: 'search',          // æœç´¢åŠŸèƒ½
  
} as const;

// âœ… å¼ºåˆ¶ï¼šç¿»è¯‘é”®å‘½åè§„èŒƒ
interface TranslationKeyStructure {
  // åŠŸèƒ½æ¨¡å—.æ“ä½œ.å…·ä½“å†…å®¹
  'auth.login.title': string;
  'auth.login.email.label': string;
  'auth.login.email.placeholder': string;
  'auth.login.email.error.required': string;
  'auth.login.email.error.invalid': string;
  'auth.login.password.label': string;
  'auth.login.submit': string;
  'auth.login.success': string;
  'auth.login.error.credentials': string;
  
  // é€šç”¨æ“ä½œ
  'common.actions.save': string;
  'common.actions.cancel': string;
  'common.actions.delete': string;
  'common.actions.edit': string;
  'common.actions.confirm': string;
  
  // çŠ¶æ€ä¿¡æ¯
  'common.status.loading': string;
  'common.status.success': string;
  'common.status.error': string;
  'common.status.empty': string;
}
```

### 2. ç¿»è¯‘æ–‡ä»¶ç»„ç»‡ï¼ˆå¼ºåˆ¶æ ‡å‡†ï¼‰

#### æ–‡ä»¶ç»“æ„ï¼ˆå¼ºåˆ¶ï¼‰
```
src/i18n/locales/
â”œâ”€â”€ zh.json                 # ä¸­æ–‡ï¼ˆç®€ä½“ï¼‰ä¸»æ–‡ä»¶
â”œâ”€â”€ zh-tw.json             # ä¸­æ–‡ï¼ˆç¹ä½“ï¼‰ä¸»æ–‡ä»¶  
â”œâ”€â”€ en.json                # è‹±æ–‡ä¸»æ–‡ä»¶
â”œâ”€â”€ ja.json                # æ—¥æ–‡ä¸»æ–‡ä»¶
â”œâ”€â”€ ko.json                # éŸ©æ–‡ä¸»æ–‡ä»¶
â”œâ”€â”€ vi.json                # è¶Šå—æ–‡ä¸»æ–‡ä»¶
â”œâ”€â”€ zh/                    # ä¸­æ–‡ï¼ˆç®€ä½“ï¼‰æ¨¡å—åŒ–
â”‚   â”œâ”€â”€ auth.json
â”‚   â”œâ”€â”€ posts.json
â”‚   â”œâ”€â”€ settings.json
â”‚   â””â”€â”€ errors.json
â”œâ”€â”€ zh-tw/                 # ä¸­æ–‡ï¼ˆç¹ä½“ï¼‰æ¨¡å—åŒ–
â”‚   â”œâ”€â”€ auth.json
â”‚   â”œâ”€â”€ posts.json
â”‚   â”œâ”€â”€ settings.json
â”‚   â””â”€â”€ errors.json
â””â”€â”€ en/                    # è‹±æ–‡æ¨¡å—åŒ–
    â”œâ”€â”€ auth.json
    â”œâ”€â”€ posts.json
    â”œâ”€â”€ settings.json
    â””â”€â”€ errors.json
```

#### ç¿»è¯‘å†…å®¹è§„èŒƒï¼ˆå¼ºåˆ¶ï¼‰
```json
// src/i18n/locales/zh/auth.json - å¼ºåˆ¶ç¿»è¯‘æ ¼å¼
{
  "login": {
    "title": "ç™»å½•åˆ°BiuBiuStar",
    "subtitle": "æ¬¢è¿å›æ¥ï¼è¯·ç™»å½•æ‚¨çš„è´¦æˆ·",
    "form": {
      "email": {
        "label": "é‚®ç®±åœ°å€",
        "placeholder": "è¯·è¾“å…¥æ‚¨çš„é‚®ç®±åœ°å€",
        "error": {
          "required": "é‚®ç®±åœ°å€ä¸èƒ½ä¸ºç©º",
          "invalid": "è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€"
        }
      },
      "password": {
        "label": "å¯†ç ", 
        "placeholder": "è¯·è¾“å…¥æ‚¨çš„å¯†ç ",
        "error": {
          "required": "å¯†ç ä¸èƒ½ä¸ºç©º",
          "minLength": "å¯†ç é•¿åº¦ä¸èƒ½å°‘äº{{min}}ä½"
        }
      },
      "rememberMe": "è®°ä½æˆ‘",
      "forgotPassword": "å¿˜è®°å¯†ç ï¼Ÿ"
    },
    "actions": {
      "submit": "ç™»å½•",
      "register": "æ³¨å†Œæ–°è´¦æˆ·",
      "socialLogin": "ä½¿ç”¨{{provider}}ç™»å½•"
    },
    "messages": {
      "success": "ç™»å½•æˆåŠŸï¼æ¬¢è¿å›æ¥ï¼Œ{{username}}ï¼",
      "error": {
        "invalidCredentials": "é‚®ç®±æˆ–å¯†ç é”™è¯¯ï¼Œè¯·é‡è¯•",
        "accountLocked": "è´¦æˆ·å·²è¢«é”å®šï¼Œè¯·ç¨åå†è¯•",
        "tooManyAttempts": "ç™»å½•å°è¯•æ¬¡æ•°è¿‡å¤šï¼Œè¯·{{minutes}}åˆ†é’Ÿåå†è¯•"
      }
    }
  },
  "register": {
    "title": "æ³¨å†ŒBiuBiuStarè´¦æˆ·",
    "subtitle": "åŠ å…¥æˆ‘ä»¬çš„ç¤¾åŒºï¼Œå¼€å§‹æ‚¨çš„ç²¾å½©æ—…ç¨‹",
    // æ›´å¤šæ³¨å†Œç›¸å…³ç¿»è¯‘...
  }
}

// src/i18n/locales/zh/posts.json - å¸–å­æ¨¡å—ç¿»è¯‘
{
  "create": {
    "title": "åˆ›å»ºæ–°å¸–å­",
    "form": {
      "content": {
        "label": "å¸–å­å†…å®¹",
        "placeholder": "åˆ†äº«æ‚¨çš„æƒ³æ³•...",
        "counter": "{{current}}/{{max}} å­—ç¬¦"
      },
      "images": {
        "label": "æ·»åŠ å›¾ç‰‡",
        "dragDrop": "æ‹–æ‹½å›¾ç‰‡åˆ°è¿™é‡Œï¼Œæˆ–ç‚¹å‡»é€‰æ‹©",
        "limit": "æœ€å¤šå¯ä¸Šä¼ {{max}}å¼ å›¾ç‰‡"
      },
      "privacy": {
        "label": "éšç§è®¾ç½®",
        "public": "å…¬å¼€",
        "friends": "ä»…å¥½å‹å¯è§", 
        "private": "ä»…è‡ªå·±å¯è§"
      }
    },
    "actions": {
      "publish": "å‘å¸ƒ",
      "saveDraft": "ä¿å­˜è‰ç¨¿",
      "preview": "é¢„è§ˆ"
    },
    "messages": {
      "success": "å¸–å­å‘å¸ƒæˆåŠŸï¼",
      "draftSaved": "è‰ç¨¿å·²ä¿å­˜",
      "error": {
        "contentRequired": "å¸–å­å†…å®¹ä¸èƒ½ä¸ºç©º",
        "contentTooLong": "å¸–å­å†…å®¹ä¸èƒ½è¶…è¿‡{{max}}å­—ç¬¦",
        "imageUploadFailed": "å›¾ç‰‡ä¸Šä¼ å¤±è´¥ï¼š{{error}}"
      }
    }
  }
}
```

### 3. React Hooké›†æˆï¼ˆå¼ºåˆ¶å®ç°ï¼‰

#### ç¿»è¯‘Hookå°è£…
```typescript
// src/hooks/useTranslation.ts - å¼ºåˆ¶ç¿»è¯‘Hook
import { useTranslation as useI18nTranslation } from 'react-i18next';
import { useMemo } from 'react';
import type { SupportedLanguage } from '@/i18n';

// âœ… å¼ºåˆ¶ï¼šå¢å¼ºçš„ç¿»è¯‘Hook
export function useTranslation(namespace?: string) {
  const { t, i18n } = useI18nTranslation(namespace);
  
  // âœ… å¼ºåˆ¶ï¼šå½“å‰è¯­è¨€ä¿¡æ¯
  const currentLanguage = useMemo(() => {
    const lang = i18n.language as SupportedLanguage;
    return SUPPORTED_LANGUAGES[lang] || SUPPORTED_LANGUAGES.zh;
  }, [i18n.language]);
  
  // âœ… å¼ºåˆ¶ï¼šæ ¼å¼åŒ–å‡½æ•°
  const formatters = useMemo(() => ({
    // æ•°å­—æ ¼å¼åŒ–
    number: (value: number, options?: Intl.NumberFormatOptions) => {
      return new Intl.NumberFormat(currentLanguage.code, options).format(value);
    },
    
    // è´§å¸æ ¼å¼åŒ–
    currency: (value: number, currency: string = 'USD') => {
      return new Intl.NumberFormat(currentLanguage.code, {
        style: 'currency',
        currency: currency.toUpperCase(),
      }).format(value);
    },
    
    // æ—¥æœŸæ ¼å¼åŒ–
    date: (date: Date | string, options?: Intl.DateTimeFormatOptions) => {
      return new Intl.DateTimeFormat(currentLanguage.code, options).format(new Date(date));
    },
    
    // ç›¸å¯¹æ—¶é—´æ ¼å¼åŒ–
    relativeTime: (date: Date | string) => {
      const rtf = new Intl.RelativeTimeFormat(currentLanguage.code, { numeric: 'auto' });
      const now = new Date();
      const target = new Date(date);
      const diffInSeconds = (target.getTime() - now.getTime()) / 1000;
      
      if (Math.abs(diffInSeconds) < 60) {
        return rtf.format(Math.round(diffInSeconds), 'second');
      } else if (Math.abs(diffInSeconds) < 3600) {
        return rtf.format(Math.round(diffInSeconds / 60), 'minute');
      } else if (Math.abs(diffInSeconds) < 86400) {
        return rtf.format(Math.round(diffInSeconds / 3600), 'hour');
      } else {
        return rtf.format(Math.round(diffInSeconds / 86400), 'day');
      }
    },
  }), [currentLanguage]);
  
  // âœ… å¼ºåˆ¶ï¼šå¤æ•°å¤„ç†
  const plural = (key: string, count: number, options?: any) => {
    return t(key, { count, ...options });
  };
  
  // âœ… å¼ºåˆ¶ï¼šä¸Šä¸‹æ–‡ç¿»è¯‘
  const contextual = (key: string, context: string, options?: any) => {
    return t(`${key}_${context}`, options) || t(key, options);
  };
  
  return {
    t,
    i18n,
    currentLanguage,
    formatters,
    plural,
    contextual,
    // ä¾¿æ·æ–¹æ³•
    changeLanguage: i18n.changeLanguage,
    isRTL: currentLanguage.direction === 'rtl',
  };
}

// âœ… å¼ºåˆ¶ï¼šå‘½åç©ºé—´ä¸“ç”¨Hook
export function useAuthTranslation() {
  return useTranslation('auth');
}

export function usePostsTranslation() {
  return useTranslation('posts');
}

export function useErrorTranslation() {
  return useTranslation('errors');
}
```

#### è¯­è¨€åˆ‡æ¢ç»„ä»¶ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```typescript
// src/components/LanguageSwitcher.tsx - å¼ºåˆ¶è¯­è¨€åˆ‡æ¢å™¨
import { useState } from 'react';
import { useTranslation } from '@/hooks/useTranslation';
import { SUPPORTED_LANGUAGES, type SupportedLanguage } from '@/i18n';

export function LanguageSwitcher() {
  const { currentLanguage, changeLanguage } = useTranslation();
  const [isOpen, setIsOpen] = useState(false);
  
  const handleLanguageChange = async (langCode: SupportedLanguage) => {
    try {
      await changeLanguage(langCode);
      setIsOpen(false);
      
      // âœ… å¼ºåˆ¶ï¼šæ›´æ–°HTML langå±æ€§
      document.documentElement.lang = langCode;
      
      // âœ… å¼ºåˆ¶ï¼šæ›´æ–°é¡µé¢æ–¹å‘
      const language = SUPPORTED_LANGUAGES[langCode];
      document.documentElement.dir = language.direction;
      
      // âœ… å¼ºåˆ¶ï¼šé€šçŸ¥ç”¨æˆ·è¯­è¨€å·²åˆ‡æ¢
      // toast.success(t('common.language.changed', { language: language.nativeName }));
    } catch (error) {
      console.error('åˆ‡æ¢è¯­è¨€å¤±è´¥:', error);
    }
  };
  
  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center space-x-2 px-3 py-2 rounded-lg hover:bg-neutral-100 dark:hover:bg-neutral-800 transition-colors"
        aria-label="é€‰æ‹©è¯­è¨€"
        aria-expanded={isOpen}
        aria-haspopup="listbox"
      >
        <span className="text-lg">{currentLanguage.flag}</span>
        <span className="text-sm font-medium">{currentLanguage.nativeName}</span>
        <ChevronDown className={`h-4 w-4 transition-transform ${isOpen ? 'rotate-180' : ''}`} />
      </button>
      
      {isOpen && (
        <div className="absolute top-full right-0 mt-1 w-48 bg-white dark:bg-neutral-800 rounded-lg shadow-lg border border-neutral-200 dark:border-neutral-700 z-50">
          <div className="py-1" role="listbox">
            {Object.entries(SUPPORTED_LANGUAGES).map(([code, language]) => (
              <button
                key={code}
                onClick={() => handleLanguageChange(code as SupportedLanguage)}
                className={`w-full flex items-center space-x-3 px-4 py-2 text-left hover:bg-neutral-100 dark:hover:bg-neutral-700 transition-colors ${
                  currentLanguage.code === code ? 'bg-primary-50 dark:bg-primary-900/20 text-primary-600 dark:text-primary-400' : ''
                }`}
                role="option"
                aria-selected={currentLanguage.code === code}
              >
                <span className="text-lg">{language.flag}</span>
                <div className="flex-1">
                  <div className="text-sm font-medium">{language.nativeName}</div>
                  <div className="text-xs text-neutral-500 dark:text-neutral-400">{language.name}</div>
                </div>
                {currentLanguage.code === code && (
                  <Check className="h-4 w-4 text-primary-500" />
                )}
              </button>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
```

---

## âš¡ æœ¬åœ°åŒ–é€‚é…è§„åˆ™ï¼ˆP1çº§ï¼‰

### 1. åœ°åŒºç‰¹å®šæ ¼å¼åŒ–

#### æ•°å­—å’Œè´§å¸æ ¼å¼åŒ–ï¼ˆæ¨èï¼‰
```typescript
// src/utils/localization.ts - æ¨èæœ¬åœ°åŒ–å·¥å…·
export class LocalizationUtils {
  // âœ… æ¨èï¼šæ™ºèƒ½è´§å¸æ ¼å¼åŒ–
  static formatCurrency(
    amount: number, 
    locale: string,
    currency?: string
  ): string {
    // æ ¹æ®åœ°åŒºæ™ºèƒ½é€‰æ‹©è´§å¸
    const currencyMap: Record<string, string> = {
      'zh': 'CNY',
      'zh-TW': 'TWD', 
      'ja': 'JPY',
      'ko': 'KRW',
      'en': 'USD',
      'vi': 'VND',
    };
    
    const targetCurrency = currency || currencyMap[locale] || 'USD';
    
    return new Intl.NumberFormat(locale, {
      style: 'currency',
      currency: targetCurrency,
      minimumFractionDigits: targetCurrency === 'JPY' ? 0 : 2,
    }).format(amount);
  }
  
  // âœ… æ¨èï¼šæ™ºèƒ½æ—¥æœŸæ ¼å¼åŒ–
  static formatDate(
    date: Date | string,
    locale: string,
    style: 'short' | 'medium' | 'long' | 'full' = 'medium'
  ): string {
    const dateObj = new Date(date);
    
    const styleMap = {
      short: { dateStyle: 'short' as const },
      medium: { dateStyle: 'medium' as const },
      long: { dateStyle: 'long' as const },
      full: { dateStyle: 'full' as const },
    };
    
    return new Intl.DateTimeFormat(locale, styleMap[style]).format(dateObj);
  }
  
  // âœ… æ¨èï¼šæ™ºèƒ½ç”µè¯å·ç æ ¼å¼åŒ–
  static formatPhoneNumber(phone: string, locale: string): string {
    // åŸºç¡€æ¸…ç†
    const cleaned = phone.replace(/\D/g, '');
    
    // æ ¹æ®åœ°åŒºæ ¼å¼åŒ–
    switch (locale) {
      case 'zh':
        // ä¸­å›½å¤§é™†ï¼š+86 138 0013 8000
        if (cleaned.length === 11) {
          return `+86 ${cleaned.slice(0, 3)} ${cleaned.slice(3, 7)} ${cleaned.slice(7)}`;
        }
        break;
      case 'en':
        // ç¾å›½ï¼š+1 (555) 123-4567
        if (cleaned.length === 10) {
          return `+1 (${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`;
        }
        break;
      case 'ja':
        // æ—¥æœ¬ï¼š+81 90-1234-5678
        if (cleaned.length === 11) {
          return `+81 ${cleaned.slice(1, 3)}-${cleaned.slice(3, 7)}-${cleaned.slice(7)}`;
        }
        break;
    }
    
    return phone; // è¿”å›åŸå§‹æ ¼å¼
  }
  
  // âœ… æ¨èï¼šåœ°å€æ ¼å¼åŒ–
  static formatAddress(address: {
    country?: string;
    state?: string;
    city?: string;
    street?: string;
    postalCode?: string;
  }, locale: string): string {
    const { country, state, city, street, postalCode } = address;
    
    // æ ¹æ®åœ°åŒºè°ƒæ•´åœ°å€é¡ºåº
    switch (locale) {
      case 'zh':
      case 'ja':
      case 'ko':
        // ä¸œäºšæ ¼å¼ï¼šå›½å®¶ çœ/å· åŸå¸‚ è¡—é“ é‚®ç¼–
        return [country, state, city, street, postalCode]
          .filter(Boolean)
          .join(' ');
          
      default:
        // è¥¿æ–¹æ ¼å¼ï¼šè¡—é“, åŸå¸‚, çœ/å· é‚®ç¼–, å›½å®¶
        return [
          street,
          [city, state].filter(Boolean).join(', '),
          postalCode,
          country
        ].filter(Boolean).join(', ');
    }
  }
}
```

### 2. RTLï¼ˆä»å³åˆ°å·¦ï¼‰æ”¯æŒ

#### RTLå¸ƒå±€é€‚é…ï¼ˆæ¨èï¼‰
```typescript
// src/hooks/useRTL.ts - RTLæ”¯æŒHook
export function useRTL() {
  const { currentLanguage } = useTranslation();
  const isRTL = currentLanguage.direction === 'rtl';
  
  useEffect(() => {
    // æ›´æ–°æ–‡æ¡£æ–¹å‘
    document.documentElement.dir = isRTL ? 'rtl' : 'ltr';
    
    // æ·»åŠ RTLç±»
    if (isRTL) {
      document.documentElement.classList.add('rtl');
    } else {
      document.documentElement.classList.remove('rtl');
    }
  }, [isRTL]);
  
  // RTLæ ·å¼å·¥å…·å‡½æ•°
  const rtlStyles = {
    // è¾¹è·è°ƒæ•´
    marginLeft: (value: string) => isRTL ? { marginRight: value } : { marginLeft: value },
    marginRight: (value: string) => isRTL ? { marginLeft: value } : { marginRight: value },
    
    // å†…è¾¹è·è°ƒæ•´
    paddingLeft: (value: string) => isRTL ? { paddingRight: value } : { paddingLeft: value },
    paddingRight: (value: string) => isRTL ? { paddingLeft: value } : { paddingRight: value },
    
    // æµ®åŠ¨è°ƒæ•´
    float: (direction: 'left' | 'right') => ({
      float: isRTL ? (direction === 'left' ? 'right' : 'left') : direction
    }),
    
    // æ–‡æœ¬å¯¹é½è°ƒæ•´
    textAlign: (align: 'left' | 'right') => ({
      textAlign: isRTL ? (align === 'left' ? 'right' : 'left') : align
    }),
  };
  
  return {
    isRTL,
    rtlStyles,
    // ä¾¿æ·ç±»å
    rtlClass: (ltrClass: string, rtlClass: string) => isRTL ? rtlClass : ltrClass,
  };
}

// âœ… æ¨èï¼šRTLå‹å¥½çš„Tailwindç±»
export const RTL_CLASSES = {
  // è¾¹è·
  'ml-4': 'ml-4 rtl:mr-4 rtl:ml-0',
  'mr-4': 'mr-4 rtl:ml-4 rtl:mr-0',
  
  // å†…è¾¹è·
  'pl-4': 'pl-4 rtl:pr-4 rtl:pl-0',
  'pr-4': 'pr-4 rtl:pl-4 rtl:pr-0',
  
  // æµ®åŠ¨
  'float-left': 'float-left rtl:float-right',
  'float-right': 'float-right rtl:float-left',
  
  // æ–‡æœ¬å¯¹é½
  'text-left': 'text-left rtl:text-right',
  'text-right': 'text-right rtl:text-left',
  
  // è¾¹æ¡†
  'border-l': 'border-l rtl:border-r rtl:border-l-0',
  'border-r': 'border-r rtl:border-l rtl:border-r-0',
} as const;
```

### 3. ç¿»è¯‘å·¥ä½œæµç¨‹

#### ç¿»è¯‘é”®ç®¡ç†ï¼ˆæ¨èï¼‰
```typescript
// scripts/i18n-utils.ts - ç¿»è¯‘å·¥å…·è„šæœ¬
import fs from 'fs';
import path from 'path';

// âœ… æ¨èï¼šç¿»è¯‘é”®æå–å·¥å…·
export class TranslationKeyExtractor {
  private extractedKeys = new Set<string>();
  
  // ä»ä»£ç ä¸­æå–ç¿»è¯‘é”®
  extractFromFile(filePath: string): void {
    const content = fs.readFileSync(filePath, 'utf-8');
    
    // åŒ¹é… t('key') å’Œ t("key") 
    const regex = /\bt\s*\(\s*['"`]([^'"`]+)['"`]/g;
    let match;
    
    while ((match = regex.exec(content)) !== null) {
      this.extractedKeys.add(match[1]);
    }
  }
  
  // æ£€æŸ¥ç¼ºå¤±çš„ç¿»è¯‘é”®
  checkMissingKeys(localeFile: string): string[] {
    const translations = JSON.parse(fs.readFileSync(localeFile, 'utf-8'));
    const existingKeys = this.flattenObject(translations);
    
    return Array.from(this.extractedKeys).filter(
      key => !existingKeys.hasOwnProperty(key)
    );
  }
  
  // ç”Ÿæˆç¿»è¯‘æ¨¡æ¿
  generateTemplate(outputPath: string): void {
    const template: Record<string, string> = {};
    
    Array.from(this.extractedKeys).forEach(key => {
      this.setNestedProperty(template, key, `TODO: ${key}`);
    });
    
    fs.writeFileSync(
      outputPath, 
      JSON.stringify(template, null, 2), 
      'utf-8'
    );
  }
  
  private flattenObject(obj: any, prefix = ''): Record<string, any> {
    let flattened: Record<string, any> = {};
    
    for (const key in obj) {
      const newKey = prefix ? `${prefix}.${key}` : key;
      
      if (typeof obj[key] === 'object' && obj[key] !== null) {
        Object.assign(flattened, this.flattenObject(obj[key], newKey));
      } else {
        flattened[newKey] = obj[key];
      }
    }
    
    return flattened;
  }
  
  private setNestedProperty(obj: any, path: string, value: any): void {
    const keys = path.split('.');
    let current = obj;
    
    for (let i = 0; i < keys.length - 1; i++) {
      if (!(keys[i] in current)) {
        current[keys[i]] = {};
      }
      current = current[keys[i]];
    }
    
    current[keys[keys.length - 1]] = value;
  }
}
```

---

## ğŸ“‹ å›½é™…åŒ–å¼€å‘æ£€æŸ¥æ¸…å•

### é…ç½®å®Œæˆæ£€æŸ¥

- [ ] **è¯­è¨€æ”¯æŒ**: æ‰€æœ‰ç›®æ ‡è¯­è¨€éƒ½æœ‰å®Œæ•´çš„ç¿»è¯‘æ–‡ä»¶
- [ ] **å‘½åç©ºé—´**: ç¿»è¯‘é”®æŒ‰åŠŸèƒ½æ¨¡å—åˆç†ç»„ç»‡
- [ ] **æ ¼å¼åŒ–**: æ•°å­—ã€æ—¥æœŸã€è´§å¸æ ¼å¼ç¬¦åˆåœ°åŒºä¹ æƒ¯
- [ ] **å¤æ•°è§„åˆ™**: æ­£ç¡®å¤„ç†ä¸åŒè¯­è¨€çš„å¤æ•°å½¢å¼

### ç”¨æˆ·ä½“éªŒæ£€æŸ¥

- [ ] **è¯­è¨€åˆ‡æ¢**: è¯­è¨€åˆ‡æ¢åŠŸèƒ½æ­£å¸¸ï¼ŒçŠ¶æ€æŒä¹…åŒ–
- [ ] **RTLæ”¯æŒ**: ä»å³åˆ°å·¦è¯­è¨€çš„å¸ƒå±€æ­£ç¡®
- [ ] **å­—ä½“æ”¯æŒ**: æ‰€æœ‰è¯­è¨€çš„å­—ä½“æ˜¾ç¤ºæ­£å¸¸
- [ ] **æ–‡æœ¬é•¿åº¦**: ä¸åŒè¯­è¨€çš„æ–‡æœ¬é•¿åº¦é€‚é…è‰¯å¥½

### å¼€å‘å·¥ä½œæµæ£€æŸ¥

- [ ] **ç¿»è¯‘å®Œæ•´æ€§**: æ²¡æœ‰ç¼ºå¤±çš„ç¿»è¯‘é”®
- [ ] **ç¿»è¯‘è´¨é‡**: ç¿»è¯‘å‡†ç¡®ã€ç¬¦åˆè¯­è¨€ä¹ æƒ¯
- [ ] **æ›´æ–°æœºåˆ¶**: æ–°åŠŸèƒ½çš„ç¿»è¯‘åŠæ—¶æ›´æ–°
- [ ] **æµ‹è¯•è¦†ç›–**: å„è¯­è¨€ç‰ˆæœ¬åŠŸèƒ½æµ‹è¯•é€šè¿‡

### æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥

- [ ] **æ‡’åŠ è½½**: ç¿»è¯‘æ–‡ä»¶æŒ‰éœ€åŠ è½½
- [ ] **ç¼“å­˜æœºåˆ¶**: åˆç†ç¼“å­˜ç¿»è¯‘èµ„æº
- [ ] **åŒ…å¤§å°**: ç¿»è¯‘æ–‡ä»¶ä¸ä¼šæ˜¾è‘—å¢åŠ åŒ…ä½“ç§¯
- [ ] **åŠ è½½é€Ÿåº¦**: è¯­è¨€åˆ‡æ¢å“åº”è¿…é€Ÿ

---

**é€‚ç”¨é¡¹ç›®**: BiuBiuStarç¤¾äº¤å¹³å°å›½é™…åŒ–  
**æ›´æ–°é¢‘ç‡**: æ–°å¢è¯­è¨€æ”¯æŒæ—¶åŒæ­¥æ›´æ–°  
**å¼ºåˆ¶æ‰§è¡Œ**: P0çº§è§„åˆ™å¿…é¡»100%éµå¾ªï¼ŒP1çº§è§„åˆ™å»ºè®®90%ä»¥ä¸Šéµå¾ª