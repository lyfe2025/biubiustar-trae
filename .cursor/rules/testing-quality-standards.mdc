---
alwaysApply: intelligently
description: æµ‹è¯•è´¨é‡ä¿è¯ä¸“ç”¨è§„èŒƒï¼ŒåŒ…å«å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€E2Eæµ‹è¯•ã€æµ‹è¯•é©±åŠ¨å¼€å‘ã€‚é€‚ç”¨äºæµ‹è¯•ç¼–å†™ã€è´¨é‡ä¿è¯ã€è‡ªåŠ¨åŒ–æµ‹è¯•ç­‰åœºæ™¯ã€‚
triggerWords: ["test", "testing", "jest", "vitest", "cypress", "playwright", "unit", "integration", "e2e", "tdd", "coverage", "mock"]
---

# æµ‹è¯•è´¨é‡ä¿è¯è§„èŒƒ

> **æµ‹è¯•æ¡†æ¶**: Vitest + Testing Library + Playwright + Jest  
> **é€‚ç”¨é¡¹ç›®**: BiuBiuStarç¤¾äº¤å¹³å° - å…¨æ ˆæµ‹è¯•ç­–ç•¥

---

## ğŸ”¥ æµ‹è¯•æ¶æ„å¼ºåˆ¶è§„åˆ™ï¼ˆP0çº§ï¼‰

### 1. æµ‹è¯•é‡‘å­—å¡”ç­–ç•¥ï¼ˆå¼ºåˆ¶ï¼‰

#### æµ‹è¯•å±‚çº§åˆ†å¸ƒï¼ˆå¼ºåˆ¶æ¯”ä¾‹ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šæµ‹è¯•é‡‘å­—å¡”æ¯”ä¾‹
export const TEST_PYRAMID = {
  // 70% - å•å…ƒæµ‹è¯•ï¼ˆå¿«é€Ÿã€ç¨³å®šã€ç»†ç²’åº¦ï¼‰
  unit: {
    percentage: 70,
    types: ['å‡½æ•°æµ‹è¯•', 'ç»„ä»¶æµ‹è¯•', 'Hookæµ‹è¯•', 'å·¥å…·å‡½æ•°æµ‹è¯•'],
    tools: ['Vitest', 'Testing Library'],
    execution: 'æ¯«ç§’çº§',
  },
  
  // 20% - é›†æˆæµ‹è¯•ï¼ˆæ¨¡å—é—´äº¤äº’ï¼‰
  integration: {
    percentage: 20,
    types: ['APIæµ‹è¯•', 'æ•°æ®åº“æµ‹è¯•', 'æœåŠ¡é›†æˆ', 'é¡µé¢äº¤äº’'],
    tools: ['Vitest', 'Supertest', 'MSW'],
    execution: 'ç§’çº§',
  },
  
  // 10% - E2Eæµ‹è¯•ï¼ˆç«¯åˆ°ç«¯ç”¨æˆ·æµç¨‹ï¼‰
  e2e: {
    percentage: 10,
    types: ['ç”¨æˆ·æ—…ç¨‹', 'å…³é”®ä¸šåŠ¡æµç¨‹', 'è·¨æµè§ˆå™¨æµ‹è¯•'],
    tools: ['Playwright', 'Cypress'],
    execution: 'åˆ†é’Ÿçº§',
  },
} as const;

// âœ… å¼ºåˆ¶ï¼šæµ‹è¯•æ–‡ä»¶ç»„ç»‡ç»“æ„
const testStructure = `
src/
â”œâ”€â”€ __tests__/              # å…¨å±€æµ‹è¯•é…ç½®
â”‚   â”œâ”€â”€ setup.ts
â”‚   â”œâ”€â”€ mocks/
â”‚   â””â”€â”€ fixtures/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Button/
â”‚   â”‚   â”œâ”€â”€ Button.tsx
â”‚   â”‚   â”œâ”€â”€ Button.test.tsx # å•å…ƒæµ‹è¯•
â”‚   â”‚   â””â”€â”€ Button.stories.tsx
â”‚   â””â”€â”€ PostCard/
â”‚       â”œâ”€â”€ PostCard.tsx
â”‚       â”œâ”€â”€ PostCard.test.tsx
â”‚       â””â”€â”€ PostCard.integration.test.tsx
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useAuth.ts
â”‚   â””â”€â”€ useAuth.test.ts
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ format.ts
â”‚   â””â”€â”€ format.test.ts
api/
â”œâ”€â”€ __tests__/
â”‚   â”œâ”€â”€ setup.ts
â”‚   â””â”€â”€ helpers/
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ auth.ts
â”‚   â””â”€â”€ auth.test.ts
â””â”€â”€ services/
    â”œâ”€â”€ AuthService.ts
    â””â”€â”€ AuthService.test.ts
tests/
â”œâ”€â”€ e2e/                    # E2Eæµ‹è¯•
â”‚   â”œâ”€â”€ auth.spec.ts
â”‚   â”œâ”€â”€ posts.spec.ts
â”‚   â””â”€â”€ user-journey.spec.ts
â””â”€â”€ integration/            # é›†æˆæµ‹è¯•
    â”œâ”€â”€ api/
    â””â”€â”€ database/
`;
```

### 2. å‰ç«¯å•å…ƒæµ‹è¯•æ ‡å‡†

#### Reactç»„ä»¶æµ‹è¯•ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šç»„ä»¶æµ‹è¯•æ¨¡æ¿
// src/components/Button/Button.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { vi } from 'vitest';
import userEvent from '@testing-library/user-event';
import { Button } from './Button';

// âœ… å¼ºåˆ¶ï¼šæµ‹è¯•ç»„ç»‡ç»“æ„
describe('Button Component', () => {
  // âœ… å¼ºåˆ¶ï¼šåŸºç¡€æ¸²æŸ“æµ‹è¯•
  describe('Rendering', () => {
    it('should render with default props', () => {
      render(<Button>Click me</Button>);
      
      const button = screen.getByRole('button', { name: /click me/i });
      expect(button).toBeInTheDocument();
      expect(button).toHaveClass('btn-primary');
    });
    
    it('should render different variants', () => {
      const { rerender } = render(<Button variant="secondary">Test</Button>);
      expect(screen.getByRole('button')).toHaveClass('btn-secondary');
      
      rerender(<Button variant="outline">Test</Button>);
      expect(screen.getByRole('button')).toHaveClass('btn-outline');
    });
    
    it('should render different sizes', () => {
      const { rerender } = render(<Button size="sm">Test</Button>);
      expect(screen.getByRole('button')).toHaveClass('btn-sm');
      
      rerender(<Button size="lg">Test</Button>);
      expect(screen.getByRole('button')).toHaveClass('btn-lg');
    });
  });
  
  // âœ… å¼ºåˆ¶ï¼šäº¤äº’è¡Œä¸ºæµ‹è¯•
  describe('Interactions', () => {
    it('should handle click events', async () => {
      const handleClick = vi.fn();
      const user = userEvent.setup();
      
      render(<Button onClick={handleClick}>Click me</Button>);
      
      await user.click(screen.getByRole('button'));
      expect(handleClick).toHaveBeenCalledTimes(1);
    });
    
    it('should not trigger click when disabled', async () => {
      const handleClick = vi.fn();
      const user = userEvent.setup();
      
      render(<Button onClick={handleClick} disabled>Click me</Button>);
      
      await user.click(screen.getByRole('button'));
      expect(handleClick).not.toHaveBeenCalled();
    });
    
    it('should handle loading state', () => {
      render(<Button isLoading>Click me</Button>);
      
      const button = screen.getByRole('button');
      expect(button).toBeDisabled();
      expect(screen.getByLabelText(/loading/i)).toBeInTheDocument();
    });
  });
  
  // âœ… å¼ºåˆ¶ï¼šå¯è®¿é—®æ€§æµ‹è¯•
  describe('Accessibility', () => {
    it('should have correct ARIA attributes', () => {
      render(<Button aria-describedby="help-text">Submit</Button>);
      
      const button = screen.getByRole('button');
      expect(button).toHaveAttribute('aria-describedby', 'help-text');
    });
    
    it('should support keyboard navigation', async () => {
      const handleClick = vi.fn();
      const user = userEvent.setup();
      
      render(<Button onClick={handleClick}>Click me</Button>);
      
      const button = screen.getByRole('button');
      button.focus();
      
      await user.keyboard('{Enter}');
      expect(handleClick).toHaveBeenCalledTimes(1);
      
      await user.keyboard(' ');
      expect(handleClick).toHaveBeenCalledTimes(2);
    });
  });
  
  // âœ… å¼ºåˆ¶ï¼šè¾¹ç•Œæ¡ä»¶æµ‹è¯•
  describe('Edge Cases', () => {
    it('should handle extremely long text', () => {
      const longText = 'A'.repeat(1000);
      render(<Button>{longText}</Button>);
      
      expect(screen.getByRole('button')).toBeInTheDocument();
    });
    
    it('should handle special characters in children', () => {
      render(<Button>{"<script>alert('xss')</script>"}</Button>);
      
      expect(screen.getByRole('button')).toHaveTextContent("<script>alert('xss')</script>");
    });
  });
});
```

#### Custom Hookæµ‹è¯•ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šHookæµ‹è¯•æ¨¡æ¿
// src/hooks/useAuth.test.ts
import { renderHook, act, waitFor } from '@testing-library/react';
import { vi } from 'vitest';
import { useAuth } from './useAuth';
import * as authAPI from '@/api/auth';

// âœ… å¼ºåˆ¶ï¼šMockå¤–éƒ¨ä¾èµ–
vi.mock('@/api/auth', () => ({
  login: vi.fn(),
  logout: vi.fn(),
  getCurrentUser: vi.fn(),
}));

describe('useAuth Hook', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();
  });
  
  // âœ… å¼ºåˆ¶ï¼šåˆå§‹çŠ¶æ€æµ‹è¯•
  describe('Initial State', () => {
    it('should have correct initial state', () => {
      const { result } = renderHook(() => useAuth());
      
      expect(result.current.user).toBeNull();
      expect(result.current.isLoading).toBe(false);
      expect(result.current.isAuthenticated).toBe(false);
    });
    
    it('should restore user from localStorage', async () => {
      const mockUser = { id: '1', email: 'test@example.com' };
      localStorage.setItem('token', 'valid-token');
      vi.mocked(authAPI.getCurrentUser).mockResolvedValue(mockUser);
      
      const { result } = renderHook(() => useAuth());
      
      expect(result.current.isLoading).toBe(true);
      
      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
        expect(result.current.user).toEqual(mockUser);
        expect(result.current.isAuthenticated).toBe(true);
      });
    });
  });
  
  // âœ… å¼ºåˆ¶ï¼šå¼‚æ­¥æ“ä½œæµ‹è¯•
  describe('Authentication Actions', () => {
    it('should handle successful login', async () => {
      const mockCredentials = { email: 'test@example.com', password: 'password' };
      const mockResponse = {
        user: { id: '1', email: 'test@example.com' },
        token: 'jwt-token'
      };
      
      vi.mocked(authAPI.login).mockResolvedValue(mockResponse);
      
      const { result } = renderHook(() => useAuth());
      
      await act(async () => {
        await result.current.login(mockCredentials);
      });
      
      expect(result.current.user).toEqual(mockResponse.user);
      expect(result.current.isAuthenticated).toBe(true);
      expect(localStorage.getItem('token')).toBe('jwt-token');
    });
    
    it('should handle login failure', async () => {
      const mockError = new Error('Invalid credentials');
      vi.mocked(authAPI.login).mockRejectedValue(mockError);
      
      const { result } = renderHook(() => useAuth());
      
      await act(async () => {
        try {
          await result.current.login({ email: 'test@example.com', password: 'wrong' });
        } catch (error) {
          expect(error).toBe(mockError);
        }
      });
      
      expect(result.current.user).toBeNull();
      expect(result.current.isAuthenticated).toBe(false);
    });
    
    it('should handle logout', async () => {
      // é¦–å…ˆè®¾ç½®ç™»å½•çŠ¶æ€
      localStorage.setItem('token', 'jwt-token');
      const { result } = renderHook(() => useAuth());
      
      await act(async () => {
        result.current.logout();
      });
      
      expect(result.current.user).toBeNull();
      expect(result.current.isAuthenticated).toBe(false);
      expect(localStorage.getItem('token')).toBeNull();
    });
  });
});
```

### 3. åç«¯APIæµ‹è¯•æ ‡å‡†

#### Expressè·¯ç”±æµ‹è¯•ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šAPIè·¯ç”±æµ‹è¯•æ¨¡æ¿
// api/routes/auth.test.ts
import request from 'supertest';
import { vi } from 'vitest';
import { app } from '../app';
import * as authService from '../services/AuthService';
import { createTestUser, cleanupTestData } from '../__tests__/helpers';

// âœ… å¼ºåˆ¶ï¼šMockæœåŠ¡å±‚
vi.mock('../services/AuthService');

describe('POST /api/auth/login', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });
  
  afterEach(async () => {
    await cleanupTestData();
  });
  
  // âœ… å¼ºåˆ¶ï¼šæˆåŠŸè·¯å¾„æµ‹è¯•
  describe('Success Cases', () => {
    it('should login with valid credentials', async () => {
      const mockUser = { id: '1', email: 'test@example.com', role: 'user' };
      const mockToken = 'jwt-token';
      
      vi.mocked(authService.login).mockResolvedValue({
        user: mockUser,
        token: mockToken
      });
      
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'test@example.com',
          password: 'password123'
        })
        .expect(200);
      
      expect(response.body).toEqual({
        success: true,
        data: {
          user: mockUser,
          token: mockToken
        }
      });
    });
  });
  
  // âœ… å¼ºåˆ¶ï¼šå¤±è´¥è·¯å¾„æµ‹è¯•
  describe('Error Cases', () => {
    it('should return 400 for missing email', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          password: 'password123'
        })
        .expect(400);
      
      expect(response.body.success).toBe(false);
      expect(response.body.error.code).toBe('VALIDATION_ERROR');
    });
    
    it('should return 401 for invalid credentials', async () => {
      vi.mocked(authService.login).mockRejectedValue(
        new Error('Invalid credentials')
      );
      
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'test@example.com',
          password: 'wrong-password'
        })
        .expect(401);
      
      expect(response.body.success).toBe(false);
    });
    
    it('should handle rate limiting', async () => {
      // å‘é€å¤šä¸ªè¯·æ±‚è§¦å‘é™æµ
      const requests = Array(6).fill(null).map(() =>
        request(app)
          .post('/api/auth/login')
          .send({
            email: 'test@example.com',
            password: 'password123'
          })
      );
      
      const responses = await Promise.all(requests);
      const lastResponse = responses[responses.length - 1];
      
      expect(lastResponse.status).toBe(429);
    });
  });
  
  // âœ… å¼ºåˆ¶ï¼šå®‰å…¨æ€§æµ‹è¯•
  describe('Security Tests', () => {
    it('should reject SQL injection attempts', async () => {
      const maliciousEmail = "'; DROP TABLE users; --";
      
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: maliciousEmail,
          password: 'password123'
        })
        .expect(400);
      
      expect(response.body.success).toBe(false);
    });
    
    it('should reject XSS attempts', async () => {
      const xssPayload = "<script>alert('xss')</script>";
      
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: xssPayload,
          password: 'password123'
        })
        .expect(400);
      
      expect(response.body.success).toBe(false);
    });
  });
});
```

#### æ•°æ®åº“é›†æˆæµ‹è¯•ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šæ•°æ®åº“æµ‹è¯•æ¨¡æ¿
// api/services/AuthService.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { AuthService } from './AuthService';
import { supabase } from '../config/supabase';
import { createTestUser, cleanupTestUsers } from '../__tests__/helpers';

describe('AuthService Integration Tests', () => {
  let authService: AuthService;
  
  beforeEach(() => {
    authService = new AuthService();
  });
  
  afterEach(async () => {
    await cleanupTestUsers();
  });
  
  // âœ… å¼ºåˆ¶ï¼šæ•°æ®åº“æ“ä½œæµ‹è¯•
  describe('User Registration', () => {
    it('should create new user successfully', async () => {
      const userData = {
        email: 'newuser@example.com',
        username: 'newuser',
        password: 'securePassword123!'
      };
      
      const result = await authService.register(userData);
      
      expect(result.user).toBeDefined();
      expect(result.user.email).toBe(userData.email);
      expect(result.user.username).toBe(userData.username);
      expect(result.token).toBeDefined();
      
      // éªŒè¯ç”¨æˆ·ç¡®å®å­˜åœ¨äºæ•°æ®åº“ä¸­
      const { data: dbUser } = await supabase
        .from('users')
        .select('*')
        .eq('email', userData.email)
        .single();
      
      expect(dbUser).toBeDefined();
      expect(dbUser.email).toBe(userData.email);
    });
    
    it('should reject duplicate email', async () => {
      const existingUser = await createTestUser({
        email: 'existing@example.com'
      });
      
      await expect(
        authService.register({
          email: 'existing@example.com',
          username: 'newuser',
          password: 'password123!'
        })
      ).rejects.toThrow('Email already exists');
    });
  });
  
  // âœ… å¼ºåˆ¶ï¼šäº‹åŠ¡æµ‹è¯•
  describe('Database Transactions', () => {
    it('should rollback on partial failure', async () => {
      const userData = {
        email: 'test@example.com',
        username: 'testuser',
        password: 'password123!'
      };
      
      // æ¨¡æ‹Ÿåœ¨ç”¨æˆ·åˆ›å»ºåçš„profileåˆ›å»ºå¤±è´¥
      const originalCreateProfile = authService.createUserProfile;
      authService.createUserProfile = vi.fn().mockRejectedValue(
        new Error('Profile creation failed')
      );
      
      await expect(
        authService.register(userData)
      ).rejects.toThrow('Profile creation failed');
      
      // éªŒè¯ç”¨æˆ·æ²¡æœ‰è¢«åˆ›å»ºï¼ˆäº‹åŠ¡å›æ»šï¼‰
      const { data: user } = await supabase
        .from('users')
        .select('*')
        .eq('email', userData.email)
        .single();
      
      expect(user).toBeNull();
      
      // æ¢å¤åŸå§‹æ–¹æ³•
      authService.createUserProfile = originalCreateProfile;
    });
  });
});
```

---

## âš¡ E2Eæµ‹è¯•å¼ºåˆ¶è§„åˆ™ï¼ˆP0çº§ï¼‰

### 1. Playwright E2Eæµ‹è¯•

#### ç”¨æˆ·æµç¨‹æµ‹è¯•ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šE2Eæµ‹è¯•æ¨¡æ¿
// tests/e2e/auth.spec.ts
import { test, expect, type Page } from '@playwright/test';

// âœ… å¼ºåˆ¶ï¼šæµ‹è¯•æ•°æ®ç®¡ç†
const TEST_USER = {
  email: 'e2e.test@example.com',
  password: 'E2eTestPassword123!',
  username: 'e2etestuser'
};

// âœ… å¼ºåˆ¶ï¼šé¡µé¢å¯¹è±¡æ¨¡å¼
class LoginPage {
  constructor(private page: Page) {}
  
  async goto() {
    await this.page.goto('/login');
  }
  
  async fillEmail(email: string) {
    await this.page.fill('[data-testid="email-input"]', email);
  }
  
  async fillPassword(password: string) {
    await this.page.fill('[data-testid="password-input"]', password);
  }
  
  async clickLogin() {
    await this.page.click('[data-testid="login-button"]');
  }
  
  async login(email: string, password: string) {
    await this.fillEmail(email);
    await this.fillPassword(password);
    await this.clickLogin();
  }
  
  async getErrorMessage() {
    return await this.page.textContent('[data-testid="error-message"]');
  }
}

test.describe('Authentication Flow', () => {
  let loginPage: LoginPage;
  
  test.beforeEach(async ({ page }) => {
    loginPage = new LoginPage(page);
  });
  
  // âœ… å¼ºåˆ¶ï¼šå…³é”®ç”¨æˆ·æµç¨‹æµ‹è¯•
  test('successful login flow', async ({ page }) => {
    await loginPage.goto();
    
    // éªŒè¯ç™»å½•é¡µé¢å…ƒç´ 
    await expect(page.locator('[data-testid="login-form"]')).toBeVisible();
    await expect(page.locator('[data-testid="email-input"]')).toBeVisible();
    await expect(page.locator('[data-testid="password-input"]')).toBeVisible();
    
    // æ‰§è¡Œç™»å½•
    await loginPage.login(TEST_USER.email, TEST_USER.password);
    
    // éªŒè¯ç™»å½•æˆåŠŸ
    await expect(page).toHaveURL('/');
    await expect(page.locator('[data-testid="user-menu"]')).toBeVisible();
    
    // éªŒè¯ç”¨æˆ·ä¿¡æ¯æ˜¾ç¤º
    const userMenu = page.locator('[data-testid="user-menu"]');
    await userMenu.click();
    await expect(page.locator('[data-testid="username"]')).toContainText(TEST_USER.username);
  });
  
  test('failed login with invalid credentials', async ({ page }) => {
    await loginPage.goto();
    
    await loginPage.login('invalid@example.com', 'wrongpassword');
    
    // éªŒè¯é”™è¯¯ä¿¡æ¯æ˜¾ç¤º
    await expect(page.locator('[data-testid="error-message"]')).toBeVisible();
    await expect(page.locator('[data-testid="error-message"]')).toContainText('Invalid credentials');
    
    // éªŒè¯ä»åœ¨ç™»å½•é¡µé¢
    await expect(page).toHaveURL('/login');
  });
  
  // âœ… å¼ºåˆ¶ï¼šè¡¨å•éªŒè¯æµ‹è¯•
  test('form validation', async ({ page }) => {
    await loginPage.goto();
    
    // æµ‹è¯•ç©ºè¡¨å•æäº¤
    await loginPage.clickLogin();
    await expect(page.locator('[data-testid="email-error"]')).toContainText('Email is required');
    await expect(page.locator('[data-testid="password-error"]')).toContainText('Password is required');
    
    // æµ‹è¯•æ— æ•ˆé‚®ç®±æ ¼å¼
    await loginPage.fillEmail('invalid-email');
    await loginPage.clickLogin();
    await expect(page.locator('[data-testid="email-error"]')).toContainText('Invalid email format');
  });
  
  // âœ… å¼ºåˆ¶ï¼šå¯è®¿é—®æ€§æµ‹è¯•
  test('accessibility compliance', async ({ page }) => {
    await loginPage.goto();
    
    // é”®ç›˜å¯¼èˆªæµ‹è¯•
    await page.keyboard.press('Tab');
    await expect(page.locator('[data-testid="email-input"]')).toBeFocused();
    
    await page.keyboard.press('Tab');
    await expect(page.locator('[data-testid="password-input"]')).toBeFocused();
    
    await page.keyboard.press('Tab');
    await expect(page.locator('[data-testid="login-button"]')).toBeFocused();
    
    // å›è½¦é”®æäº¤æµ‹è¯•
    await loginPage.fillEmail(TEST_USER.email);
    await loginPage.fillPassword(TEST_USER.password);
    await page.keyboard.press('Enter');
    
    await expect(page).toHaveURL('/');
  });
});
```

#### è·¨æµè§ˆå™¨æµ‹è¯•é…ç½®ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šPlaywrighté…ç½®
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: [
    ['html'],
    ['json', { outputFile: 'test-results/results.json' }],
    ['junit', { outputFile: 'test-results/junit.xml' }],
  ],
  
  use: {
    baseURL: process.env.BASE_URL || 'http://localhost:5173',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
  },
  
  // âœ… å¼ºåˆ¶ï¼šå¤šæµè§ˆå™¨æµ‹è¯•é…ç½®
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'mobile-chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'mobile-safari',
      use: { ...devices['iPhone 12'] },
    },
  ],
  
  // âœ… å¼ºåˆ¶ï¼šæµ‹è¯•æœåŠ¡å™¨é…ç½®
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:5173',
    reuseExistingServer: !process.env.CI,
    timeout: 120 * 1000,
  },
});
```

---

## ğŸ› ï¸ æµ‹è¯•å·¥å…·é…ç½®ï¼ˆP1çº§ï¼‰

### 1. Mockç­–ç•¥

#### MSW (Mock Service Worker) é…ç½®ï¼ˆæ¨èï¼‰
```typescript
// âœ… æ¨èï¼šMSW mocké…ç½®
// src/__tests__/mocks/handlers.ts
import { http, HttpResponse } from 'msw';

export const handlers = [
  // âœ… è®¤è¯ç›¸å…³Mock
  http.post('/api/auth/login', async ({ request }) => {
    const body = await request.json() as { email: string; password: string };
    
    if (body.email === 'test@example.com' && body.password === 'password123') {
      return HttpResponse.json({
        success: true,
        data: {
          user: {
            id: '1',
            email: 'test@example.com',
            username: 'testuser',
            role: 'user'
          },
          token: 'mock-jwt-token'
        }
      });
    }
    
    return HttpResponse.json(
      {
        success: false,
        error: { code: 'INVALID_CREDENTIALS' },
        message: 'Invalid email or password'
      },
      { status: 401 }
    );
  }),
  
  // âœ… å¸–å­ç›¸å…³Mock
  http.get('/api/posts', ({ request }) => {
    const url = new URL(request.url);
    const page = parseInt(url.searchParams.get('page') || '1');
    const limit = parseInt(url.searchParams.get('limit') || '10');
    
    const mockPosts = Array.from({ length: limit }, (_, index) => ({
      id: `post-${page}-${index + 1}`,
      title: `Mock Post ${page}-${index + 1}`,
      content: 'This is a mock post content',
      author: {
        id: '1',
        username: 'testuser'
      },
      createdAt: new Date().toISOString(),
      likesCount: Math.floor(Math.random() * 100),
      commentsCount: Math.floor(Math.random() * 20)
    }));
    
    return HttpResponse.json({
      success: true,
      data: mockPosts,
      pagination: {
        page,
        limit,
        total: 100,
        totalPages: 10
      }
    });
  }),
  
  // âœ… é”™è¯¯åœºæ™¯Mock
  http.get('/api/posts/:id', ({ params }) => {
    const { id } = params;
    
    if (id === 'error-post') {
      return HttpResponse.json(
        {
          success: false,
          error: { code: 'INTERNAL_ERROR' },
          message: 'Internal server error'
        },
        { status: 500 }
      );
    }
    
    if (id === 'not-found') {
      return HttpResponse.json(
        {
          success: false,
          error: { code: 'NOT_FOUND' },
          message: 'Post not found'
        },
        { status: 404 }
      );
    }
    
    return HttpResponse.json({
      success: true,
      data: {
        id,
        title: `Mock Post ${id}`,
        content: 'This is a mock post content',
        author: {
          id: '1',
          username: 'testuser'
        },
        createdAt: new Date().toISOString()
      }
    });
  }),
];

// src/__tests__/setup.ts
import { beforeAll, afterEach, afterAll } from 'vitest';
import { setupServer } from 'msw/node';
import { handlers } from './mocks/handlers';

const server = setupServer(...handlers);

beforeAll(() => {
  server.listen();
});

afterEach(() => {
  server.resetHandlers();
});

afterAll(() => {
  server.close();
});
```

### 2. æµ‹è¯•è¦†ç›–ç‡é…ç½®

#### Vitestè¦†ç›–ç‡é…ç½®ï¼ˆæ¨èï¼‰
```typescript
// âœ… æ¨èï¼šVitesté…ç½®
// vitest.config.ts
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/__tests__/setup.ts'],
    
    // âœ… è¦†ç›–ç‡é…ç½®
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html', 'lcov', 'json'],
      exclude: [
        'node_modules/',
        'src/__tests__/',
        '**/*.d.ts',
        '**/*.config.*',
        '**/types.ts',
        'src/main.tsx',
        'src/vite-env.d.ts',
      ],
      // âœ… å¼ºåˆ¶ï¼šè¦†ç›–ç‡é˜ˆå€¼
      thresholds: {
        global: {
          statements: 80,
          branches: 75,
          functions: 80,
          lines: 80,
        },
        // å…³é”®æ¨¡å—æ›´é«˜è¦æ±‚
        'src/utils/': {
          statements: 95,
          branches: 90,
          functions: 95,
          lines: 95,
        },
        'src/hooks/': {
          statements: 90,
          branches: 85,
          functions: 90,
          lines: 90,
        },
      },
    },
  },
  
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});
```

---

## ğŸ“‹ æµ‹è¯•è´¨é‡æ£€æŸ¥æ¸…å•

### å•å…ƒæµ‹è¯•å®Œæˆæ£€æŸ¥

- [ ] **æµ‹è¯•è¦†ç›–ç‡**: å…³é”®æ¨¡å—è¦†ç›–ç‡è¾¾åˆ°90%ä»¥ä¸Š
- [ ] **æµ‹è¯•ç»„ç»‡**: æµ‹è¯•æŒ‰åŠŸèƒ½æ¨¡å—æ¸…æ™°ç»„ç»‡
- [ ] **Mockä½¿ç”¨**: å¤–éƒ¨ä¾èµ–æ­£ç¡®Mockï¼Œæµ‹è¯•éš”ç¦»
- [ ] **è¾¹ç•Œæµ‹è¯•**: åŒ…å«æ­£å¸¸ã€å¼‚å¸¸ã€è¾¹ç•Œæ¡ä»¶æµ‹è¯•

### é›†æˆæµ‹è¯•å®Œæˆæ£€æŸ¥

- [ ] **APIæµ‹è¯•**: æ‰€æœ‰APIç«¯ç‚¹æœ‰é›†æˆæµ‹è¯•
- [ ] **æ•°æ®åº“æµ‹è¯•**: æ•°æ®åº“æ“ä½œæœ‰é›†æˆæµ‹è¯•
- [ ] **æœåŠ¡é›†æˆ**: æœåŠ¡é—´äº¤äº’æµ‹è¯•å®Œæ•´
- [ ] **é”™è¯¯å¤„ç†**: å¼‚å¸¸æƒ…å†µå¤„ç†æµ‹è¯•è¦†ç›–

### E2Eæµ‹è¯•å®Œæˆæ£€æŸ¥

- [ ] **ç”¨æˆ·æµç¨‹**: å…³é”®ç”¨æˆ·æ—…ç¨‹æµ‹è¯•è¦†ç›–
- [ ] **è·¨æµè§ˆå™¨**: ä¸»æµæµè§ˆå™¨å…¼å®¹æ€§æµ‹è¯•
- [ ] **ç§»åŠ¨ç«¯**: ç§»åŠ¨è®¾å¤‡å“åº”å¼æµ‹è¯•
- [ ] **å¯è®¿é—®æ€§**: é”®ç›˜å¯¼èˆªå’Œå±å¹•é˜…è¯»å™¨æµ‹è¯•

### æµ‹è¯•æ€§èƒ½æ£€æŸ¥

- [ ] **æ‰§è¡Œé€Ÿåº¦**: å•å…ƒæµ‹è¯•ç§’çº§å®Œæˆï¼ŒE2Eæµ‹è¯•åˆ†é’Ÿçº§å®Œæˆ
- [ ] **å¹¶è¡Œæ‰§è¡Œ**: æµ‹è¯•æ”¯æŒå¹¶è¡Œæ‰§è¡Œ
- [ ] **CIé›†æˆ**: æµ‹è¯•åœ¨CI/CDç®¡é“ä¸­æ­£å¸¸è¿è¡Œ
- [ ] **æŠ¥å‘Šç”Ÿæˆ**: æµ‹è¯•ç»“æœå’Œè¦†ç›–ç‡æŠ¥å‘Šå®Œæ•´

---

**é€‚ç”¨é¡¹ç›®**: BiuBiuStarç¤¾äº¤å¹³å°æµ‹è¯•è´¨é‡ä¿è¯  
**æ›´æ–°é¢‘ç‡**: æµ‹è¯•æ¡†æ¶å‡çº§æ—¶åŒæ­¥æ›´æ–°  
**å¼ºåˆ¶æ‰§è¡Œ**: P0çº§è§„åˆ™å¿…é¡»100%éµå¾ªï¼ŒP1çº§è§„åˆ™å»ºè®®85%ä»¥ä¸Šéµå¾ª