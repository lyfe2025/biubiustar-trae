---
alwaysApply: intelligently
description: å…¨æ ˆç¤¾äº¤å¹³å°å¼€å‘ä¸“ç”¨è§„èŒƒï¼ŒåŒ…å«é¡¹ç›®æ¶æ„ã€æ•°æ®æµè®¾è®¡ã€è®¤è¯æˆæƒã€æ€§èƒ½ç›‘æ§ã€‚é€‚ç”¨äºå…¨æ ˆå¼€å‘ã€ç³»ç»Ÿæ¶æ„ã€é¡¹ç›®ç®¡ç†ç­‰åœºæ™¯ã€‚
triggerWords: ["fullstack", "architecture", "platform", "project", "system", "deployment", "monitoring", "performance", "scalability"]
---
## ğŸ›¡ï¸ å®‰å…¨æ¶æ„å¼ºåˆ¶è§„åˆ™ï¼ˆP0çº§ï¼‰

### 1. è®¤è¯æˆæƒæµç¨‹ï¼ˆå¼ºåˆ¶å®ç°ï¼‰

#### JWTè®¤è¯æµç¨‹
```typescript
// âœ… å¼ºåˆ¶ï¼šå®Œæ•´è®¤è¯æµç¨‹
// 1. å‰ç«¯ç™»å½• -> 2. åç«¯éªŒè¯ -> 3. è¿”å›JWT -> 4. å‰ç«¯å­˜å‚¨ -> 5. åç»­è¯·æ±‚æºå¸¦

// å‰ç«¯è®¤è¯Context
interface AuthContextType {
  user: User | null;
  token: string | null;
  isLoading: boolean;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
  refreshToken: () => Promise<void>;
}

export const AuthContext = createContext<AuthContextType | null>(null);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [token, setToken] = useState<string | null>(
    localStorage.getItem('token')
  );
  const [isLoading, setIsLoading] = useState(true);
  
  // âœ… å¼ºåˆ¶ï¼šç™»å½•æ–¹æ³•
  const login = async (credentials: LoginCredentials) => {
    setIsLoading(true);
    try {
      const response = await api.post<{
        user: User;
        token: string;
        refreshToken: string;
      }>('/auth/login', credentials);
      
      if (response.data) {
        const { user, token, refreshToken } = response.data;
        
        setUser(user);
        setToken(token);
        
        // âœ… å¼ºåˆ¶ï¼šå®‰å…¨å­˜å‚¨token
        localStorage.setItem('token', token);
        localStorage.setItem('refreshToken', refreshToken);
        
        // è®¾ç½®è‡ªåŠ¨åˆ·æ–°
        scheduleTokenRefresh(token);
      }
    } catch (error) {
      console.error('ç™»å½•å¤±è´¥:', error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };
  
  // âœ… å¼ºåˆ¶ï¼štokenåˆ·æ–°é€»è¾‘
  const refreshToken = async () => {
    const refreshToken = localStorage.getItem('refreshToken');
    if (!refreshToken) {
      logout();
      return;
    }
    
    try {
      const response = await api.post<{
        token: string;
        refreshToken: string;
      }>('/auth/refresh', { refreshToken });
      
      if (response.data) {
        const { token: newToken, refreshToken: newRefreshToken } = response.data;
        
        setToken(newToken);
        localStorage.setItem('token', newToken);
        localStorage.setItem('refreshToken', newRefreshToken);
        
        scheduleTokenRefresh(newToken);
      }
    } catch (error) {
      console.error('åˆ·æ–°tokenå¤±è´¥:', error);
      logout();
    }
  };
  
  // âœ… å¼ºåˆ¶ï¼šç™»å‡ºæ–¹æ³•
  const logout = () => {
    setUser(null);
    setToken(null);
    localStorage.removeItem('token');
    localStorage.removeItem('refreshToken');
    
    // æ¸…ç†å®šæ—¶å™¨
    clearTokenRefreshTimeout();
  };
  
  // âœ… å¼ºåˆ¶ï¼šåˆå§‹åŒ–æ—¶éªŒè¯token
  useEffect(() => {
    const initAuth = async () => {
      const storedToken = localStorage.getItem('token');
      
      if (storedToken) {
        try {
          // éªŒè¯tokenå¹¶è·å–ç”¨æˆ·ä¿¡æ¯
          const response = await api.get<User>('/auth/me');
          if (response.data) {
            setUser(response.data);
            scheduleTokenRefresh(storedToken);
          } else {
            logout();
          }
        } catch (error) {
          console.error('éªŒè¯tokenå¤±è´¥:', error);
          logout();
        }
      }
      
      setIsLoading(false);
    };
    
    initAuth();
  }, []);
  
  return (
    <AuthContext.Provider value={{
      user,
      token,
      isLoading,
      login,
      logout,
      refreshToken
    }}>
      {children}
    </AuthContext.Provider>
  );
}
```

### 2. æƒé™æ§åˆ¶å¼ºåˆ¶å®ç°

#### åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶(RBAC)
```typescript
// âœ… å¼ºåˆ¶ï¼šæƒé™æšä¸¾å®šä¹‰
export enum Permission {
  // ç”¨æˆ·æƒé™
  READ_USERS = 'read:users',
  UPDATE_PROFILE = 'update:profile',
  DELETE_ACCOUNT = 'delete:account',
  
  // å†…å®¹æƒé™
  CREATE_POST = 'create:post',
  UPDATE_POST = 'update:post',
  DELETE_POST = 'delete:post',
  MODERATE_POST = 'moderate:post',
  
  // ç®¡ç†æƒé™
  MANAGE_USERS = 'manage:users',
  MANAGE_CONTENT = 'manage:content',
  VIEW_ANALYTICS = 'view:analytics',
  SYSTEM_CONFIG = 'system:config',
}

// âœ… å¼ºåˆ¶ï¼šè§’è‰²æƒé™æ˜ å°„
export const RolePermissions: Record<UserRole, Permission[]> = {
  user: [
    Permission.READ_USERS,
    Permission.UPDATE_PROFILE,
    Permission.DELETE_ACCOUNT,
    Permission.CREATE_POST,
    Permission.UPDATE_POST,
    Permission.DELETE_POST,
  ],
  moderator: [
    ...RolePermissions.user,
    Permission.MODERATE_POST,
    Permission.MANAGE_CONTENT,
  ],
  admin: [
    ...RolePermissions.moderator,
    Permission.MANAGE_USERS,
    Permission.VIEW_ANALYTICS,
  ],
  super_admin: [
    ...RolePermissions.admin,
    Permission.SYSTEM_CONFIG,
  ],
};

// âœ… å¼ºåˆ¶ï¼šæƒé™æ£€æŸ¥Hook
export function usePermission() {
  const { user } = useAuth();
  
  const hasPermission = useCallback((permission: Permission): boolean => {
    if (!user || !user.role) return false;
    
    const rolePermissions = RolePermissions[user.role];
    return rolePermissions.includes(permission);
  }, [user]);
  
  const hasAnyPermission = useCallback((permissions: Permission[]): boolean => {
    return permissions.some(permission => hasPermission(permission));
  }, [hasPermission]);
  
  const hasAllPermissions = useCallback((permissions: Permission[]): boolean => {
    return permissions.every(permission => hasPermission(permission));
  }, [hasPermission]);
  
  return {
    hasPermission,
    hasAnyPermission,
    hasAllPermissions,
  };
}

// âœ… å¼ºåˆ¶ï¼šæƒé™ä¿æŠ¤ç»„ä»¶
interface ProtectedComponentProps {
  permission: Permission | Permission[];
  fallback?: React.ReactNode;
  children: React.ReactNode;
}

export function ProtectedComponent({ 
  permission, 
  fallback = null, 
  children 
}: ProtectedComponentProps) {
  const { hasPermission, hasAnyPermission } = usePermission();
  
  const isAuthorized = Array.isArray(permission)
    ? hasAnyPermission(permission)
    : hasPermission(permission);
  
  if (!isAuthorized) {
    return <>{fallback}</>;
  }
  
  return <>{children}</>;
}
```

#### è·¯ç”±æƒé™ä¿æŠ¤
```typescript
// âœ… å¼ºåˆ¶ï¼šè·¯ç”±ä¿æŠ¤ç»„ä»¶
interface ProtectedRouteProps {
  permission?: Permission | Permission[];
  requireAuth?: boolean;
  redirectTo?: string;
  children: React.ReactNode;
}

export function ProtectedRoute({
  permission,
  requireAuth = true,
  redirectTo = '/login',
  children
}: ProtectedRouteProps) {
  const { user, isLoading } = useAuth();
  const { hasPermission, hasAnyPermission } = usePermission();
  
  if (isLoading) {
    return <PageLoader />;
  }
  
  // æ£€æŸ¥è®¤è¯
  if (requireAuth && !user) {
    return <Navigate to={redirectTo} replace />;
  }
  
  // æ£€æŸ¥æƒé™
  if (permission) {
    const isAuthorized = Array.isArray(permission)
      ? hasAnyPermission(permission)
      : hasPermission(permission);
    
    if (!isAuthorized) {
      return <Navigate to="/unauthorized" replace />;
    }
  }
  
  return <>{children}</>;
}

// âœ… å¼ºåˆ¶ï¼šè·¯ç”±é…ç½®
export function AppRoutes() {
  return (
    <Routes>
      {/* å…¬å¼€è·¯ç”± */}
      <Route path="/" element={<Home />} />
      <Route path="/login" element={<Login />} />
      <Route path="/register" element={<Register />} />
      
      {/* è®¤è¯è·¯ç”± */}
      <Route path="/profile" element={
        <ProtectedRoute>
          <Profile />
        </ProtectedRoute>
      } />
      
      <Route path="/create" element={
        <ProtectedRoute permission={Permission.CREATE_POST}>
          <CreatePost />
        </ProtectedRoute>
      } />
      
      {/* ç®¡ç†è·¯ç”± */}
      <Route path="/admin/*" element={
        <ProtectedRoute permission={[Permission.MANAGE_USERS, Permission.MANAGE_CONTENT]}>
          <AdminRoutes />
        </ProtectedRoute>
      } />
      
      {/* 404 */}
      <Route path="*" element={<NotFound />} />
    </Routes>
  );
}
```

---

## ğŸš€ æ€§èƒ½ä¼˜åŒ–å¼ºåˆ¶è§„åˆ™ï¼ˆP1çº§ï¼‰

### 1. å‰ç«¯æ€§èƒ½ä¼˜åŒ–

#### ä»£ç åˆ†å‰²ä¸æ‡’åŠ è½½ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šé¡µé¢çº§åˆ«ä»£ç åˆ†å‰²
const HomePage = lazy(() => import('@/pages/Home'));
const ProfilePage = lazy(() => import('@/pages/Profile'));
const AdminPage = lazy(() => import('@/pages/Admin'));

// âœ… å¼ºåˆ¶ï¼šç»„ä»¶çº§åˆ«æ‡’åŠ è½½ï¼ˆå¤§å‹ç»„ä»¶ï¼‰
const PostEditor = lazy(() => import('@/components/PostEditor'));
const MediaViewer = lazy(() => import('@/components/MediaViewer'));

// âœ… å¼ºåˆ¶ï¼šç¬¬ä¸‰æ–¹åº“åŠ¨æ€å¯¼å…¥
const loadChartLibrary = async () => {
  const { Chart } = await import('chart.js');
  return Chart;
};

// âœ… å¼ºåˆ¶ï¼šé¢„åŠ è½½å…³é”®è·¯ç”±
export function useRoutePreloading() {
  useEffect(() => {
    // é¢„åŠ è½½ç”¨æˆ·å¯èƒ½è®¿é—®çš„é¡µé¢
    const timer = setTimeout(() => {
      import('@/pages/Profile');
      import('@/pages/CreatePost');
    }, 2000);
    
    return () => clearTimeout(timer);
  }, []);
}
```

#### å›¾ç‰‡ä¼˜åŒ–ç­–ç•¥ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šå“åº”å¼å›¾ç‰‡ç»„ä»¶
interface OptimizedImageProps {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  className?: string;
  loading?: 'lazy' | 'eager';
  priority?: boolean;
}

export function OptimizedImage({
  src,
  alt,
  width,
  height,
  className,
  loading = 'lazy',
  priority = false,
}: OptimizedImageProps) {
  const [imageSrc, setImageSrc] = useState<string>();
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(false);
  
  useEffect(() => {
    if (src) {
      // âœ… å¼ºåˆ¶ï¼šç”Ÿæˆå“åº”å¼å›¾ç‰‡URL
      const optimizedSrc = generateOptimizedImageUrl(src, { width, height });
      setImageSrc(optimizedSrc);
    }
  }, [src, width, height]);
  
  const handleLoad = () => {
    setIsLoading(false);
  };
  
  const handleError = () => {
    setError(true);
    setIsLoading(false);
  };
  
  if (error) {
    return (
      <div className={`bg-gray-200 flex items-center justify-center ${className}`}>
        <span className="text-gray-400">å›¾ç‰‡åŠ è½½å¤±è´¥</span>
      </div>
    );
  }
  
  return (
    <div className={`relative ${className}`}>
      {isLoading && (
        <div className="absolute inset-0 bg-gray-200 animate-pulse" />
      )}
      <img
        src={imageSrc}
        alt={alt}
        width={width}
        height={height}
        loading={priority ? 'eager' : loading}
        className={`transition-opacity duration-300 ${
          isLoading ? 'opacity-0' : 'opacity-100'
        }`}
        onLoad={handleLoad}
        onError={handleError}
      />
    </div>
  );
}

// âœ… å¼ºåˆ¶ï¼šå›¾ç‰‡URLä¼˜åŒ–å‡½æ•°
function generateOptimizedImageUrl(
  src: string, 
  options: { width?: number; height?: number; quality?: number }
): string {
  const { width, height, quality = 80 } = options;
  
  // å¦‚æœæ˜¯Supabaseå­˜å‚¨çš„å›¾ç‰‡ï¼Œæ·»åŠ å˜æ¢å‚æ•°
  if (src.includes('supabase')) {
    const url = new URL(src);
    if (width) url.searchParams.set('width', width.toString());
    if (height) url.searchParams.set('height', height.toString());
    url.searchParams.set('quality', quality.toString());
    return url.toString();
  }
  
  return src;
}
```

### 2. åç«¯æ€§èƒ½ä¼˜åŒ–

#### æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šåˆ†é¡µæŸ¥è¯¢ä¼˜åŒ–
export class PostService {
  async getPostsWithOptimization(options: {
    page: number;
    limit: number;
    userId?: string;
    includeUserData?: boolean;
  }): Promise<{ posts: Post[]; total: number }> {
    const { page, limit, userId, includeUserData = true } = options;
    const offset = (page - 1) * limit;
    
    // âœ… å¼ºåˆ¶ï¼šä½¿ç”¨ç´¢å¼•ä¼˜åŒ–çš„æŸ¥è¯¢
    let query = supabase
      .from('posts')
      .select(
        includeUserData 
          ? `
            *,
            user:user_id!inner (
              id,
              username,
              display_name,
              avatar_url,
              is_verified
            )
          `
          : '*',
        { count: 'exact' }
      );
    
    // âœ… å¼ºåˆ¶ï¼šç­›é€‰æ¡ä»¶ä¼˜åŒ–
    if (userId) {
      query = query.eq('user_id', userId);
    }
    
    // âœ… å¼ºåˆ¶ï¼šåªæŸ¥è¯¢å·²å‘å¸ƒçš„å¸–å­
    query = query.eq('status', 'published');
    
    // âœ… å¼ºåˆ¶ï¼šä½¿ç”¨å¤åˆç´¢å¼•æ’åº
    query = query
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);
    
    const { data, error, count } = await query;
    
    if (error) {
      throw new DatabaseError('è·å–å¸–å­åˆ—è¡¨å¤±è´¥', error);
    }
    
    return {
      posts: data || [],
      total: count || 0
    };
  }
  
  // âœ… å¼ºåˆ¶ï¼šæ‰¹é‡æ“ä½œä¼˜åŒ–
  async batchUpdatePostCounts(postIds: string[]): Promise<void> {
    // ä½¿ç”¨æ•°æ®åº“å‡½æ•°è¿›è¡Œæ‰¹é‡æ›´æ–°
    const { error } = await supabase.rpc('batch_update_post_counts', {
      post_ids: postIds
    });
    
    if (error) {
      throw new DatabaseError('æ‰¹é‡æ›´æ–°å¸–å­ç»Ÿè®¡å¤±è´¥', error);
    }
  }
}
```

#### ç¼“å­˜ç­–ç•¥ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šRedisç¼“å­˜é›†æˆ
export class CacheService {
  private redis: Redis;
  
  constructor() {
    this.redis = new Redis(process.env.REDIS_URL);
  }
  
  // âœ… å¼ºåˆ¶ï¼šçƒ­é—¨å†…å®¹ç¼“å­˜
  async getHotPosts(limit: number = 10): Promise<Post[] | null> {
    const cacheKey = `hot_posts:${limit}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached);
    }
    
    return null;
  }
  
  async setHotPosts(posts: Post[], limit: number = 10): Promise<void> {
    const cacheKey = `hot_posts:${limit}`;
    await this.redis.setex(cacheKey, 300, JSON.stringify(posts)); // 5åˆ†é’Ÿç¼“å­˜
  }
  
  // âœ… å¼ºåˆ¶ï¼šç”¨æˆ·æ•°æ®ç¼“å­˜
  async getUserProfile(userId: string): Promise<User | null> {
    const cacheKey = `user_profile:${userId}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached);
    }
    
    return null;
  }
  
  async setUserProfile(user: User): Promise<void> {
    const cacheKey = `user_profile:${user.id}`;
    await this.redis.setex(cacheKey, 1800, JSON.stringify(user)); // 30åˆ†é’Ÿç¼“å­˜
  }
  
  // âœ… å¼ºåˆ¶ï¼šç¼“å­˜å¤±æ•ˆ
  async invalidateUserCache(userId: string): Promise<void> {
    const pattern = `user_profile:${userId}`;
    await this.redis.del(pattern);
  }
}

// âœ… å¼ºåˆ¶ï¼šç¼“å­˜è£…é¥°å™¨
export function CacheResult(ttl: number = 300) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      const cacheKey = `${target.constructor.name}:${propertyName}:${JSON.stringify(args)}`;
      const cached = await cache.get(cacheKey);
      
      if (cached) {
        return cached;
      }
      
      const result = await method.apply(this, args);
      await cache.set(cacheKey, result, ttl);
      
      return result;
    };
  };
}
```

---

## ğŸ“Š ç›‘æ§ä¸è§‚æµ‹å¼ºåˆ¶è§„åˆ™ï¼ˆP1çº§ï¼‰

### 1. é”™è¯¯ç›‘æ§

#### å‰ç«¯é”™è¯¯ç›‘æ§ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šå…¨å±€é”™è¯¯è¾¹ç•Œ
interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
  errorInfo?: ErrorInfo;
}

export class ErrorBoundary extends Component<
  { children: ReactNode },
  ErrorBoundaryState
> {
  constructor(props: { children: ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return {
      hasError: true,
      error,
    };
  }
  
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // âœ… å¼ºåˆ¶ï¼šé”™è¯¯ä¸ŠæŠ¥
    this.reportError(error, errorInfo);
    
    this.setState({
      error,
      errorInfo,
    });
  }
  
  private reportError(error: Error, errorInfo: ErrorInfo) {
    const errorReport = {
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: window.location.href,
      userId: this.getCurrentUserId(),
    };
    
    // å‘é€åˆ°é”™è¯¯ç›‘æ§æœåŠ¡
    fetch('/api/errors', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(errorReport),
    }).catch(console.error);
  }
  
  private getCurrentUserId(): string | null {
    // ä»è®¤è¯ä¸Šä¸‹æ–‡è·å–ç”¨æˆ·ID
    return localStorage.getItem('userId');
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen flex items-center justify-center bg-gray-50">
          <div className="max-w-md w-full bg-white shadow-lg rounded-lg p-6">
            <h2 className="text-xl font-semibold text-gray-900 mb-4">
              å‡ºç°äº†ä¸€äº›é—®é¢˜
            </h2>
            <p className="text-gray-600 mb-4">
              æˆ‘ä»¬å·²ç»è®°å½•äº†è¿™ä¸ªé”™è¯¯ï¼Œæ­£åœ¨åŠªåŠ›ä¿®å¤ã€‚è¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚
            </p>
            <button
              onClick={() => window.location.reload()}
              className="w-full bg-primary-600 text-white py-2 px-4 rounded-md hover:bg-primary-700"
            >
              åˆ·æ–°é¡µé¢
            </button>
          </div>
        </div>
      );
    }
    
    return this.props.children;
  }
}
```

#### åç«¯é”™è¯¯ç›‘æ§ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šé”™è¯¯æ”¶é›†ä¸­é—´ä»¶
export const errorTracking = (
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  // âœ… å¼ºåˆ¶ï¼šé”™è¯¯åˆ†ç±»
  const errorType = classifyError(error);
  
  // âœ… å¼ºåˆ¶ï¼šé”™è¯¯ä¸ŠæŠ¥
  const errorReport = {
    message: error.message,
    stack: error.stack,
    type: errorType,
    timestamp: new Date().toISOString(),
    
    // è¯·æ±‚ä¿¡æ¯
    method: req.method,
    url: req.url,
    headers: req.headers,
    body: req.body,
    params: req.params,
    query: req.query,
    
    // ç”¨æˆ·ä¿¡æ¯
    userId: (req as any).user?.id,
    userAgent: req.get('user-agent'),
    ip: req.ip,
    
    // æœåŠ¡å™¨ä¿¡æ¯
    nodeVersion: process.version,
    memory: process.memoryUsage(),
    uptime: process.uptime(),
  };
  
  // è®°å½•åˆ°æ—¥å¿—ç³»ç»Ÿ
  logger.error('APIé”™è¯¯', errorReport);
  
  // ä¸¥é‡é”™è¯¯å‘é€å‘Šè­¦
  if (errorType === 'CRITICAL') {
    sendAlert(errorReport);
  }
  
  next(error);
};

function classifyError(error: Error): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {
  if (error instanceof AppError) {
    if (error.statusCode >= 500) return 'HIGH';
    if (error.statusCode >= 400) return 'MEDIUM';
    return 'LOW';
  }
  
  // ç³»ç»Ÿé”™è¯¯é»˜è®¤ä¸ºé«˜ä¼˜å…ˆçº§
  return 'CRITICAL';
}
```

### 2. æ€§èƒ½ç›‘æ§

#### å…³é”®æŒ‡æ ‡ç›‘æ§ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šæ€§èƒ½æŒ‡æ ‡æ”¶é›†
export class PerformanceMonitor {
  private static instance: PerformanceMonitor;
  
  static getInstance(): PerformanceMonitor {
    if (!PerformanceMonitor.instance) {
      PerformanceMonitor.instance = new PerformanceMonitor();
    }
    return PerformanceMonitor.instance;
  }
  
  // âœ… å¼ºåˆ¶ï¼šAPIå“åº”æ—¶é—´ç›‘æ§
  trackApiCall(
    endpoint: string,
    method: string,
    duration: number,
    statusCode: number
  ): void {
    const metric = {
      type: 'api_call',
      endpoint,
      method,
      duration,
      statusCode,
      timestamp: Date.now(),
    };
    
    this.sendMetric(metric);
    
    // æ…¢æŸ¥è¯¢å‘Šè­¦
    if (duration > 3000) { // 3ç§’
      logger.warn('æ…¢APIè°ƒç”¨', metric);
    }
  }
  
  // âœ… å¼ºåˆ¶ï¼šæ•°æ®åº“æŸ¥è¯¢ç›‘æ§
  trackDatabaseQuery(
    query: string,
    duration: number,
    rowCount: number
  ): void {
    const metric = {
      type: 'database_query',
      query: query.substring(0, 200), // æˆªæ–­é•¿æŸ¥è¯¢
      duration,
      rowCount,
      timestamp: Date.now(),
    };
    
    this.sendMetric(metric);
    
    // æ…¢æŸ¥è¯¢å‘Šè­¦
    if (duration > 1000) { // 1ç§’
      logger.warn('æ…¢æ•°æ®åº“æŸ¥è¯¢', metric);
    }
  }
  
  // âœ… å¼ºåˆ¶ï¼šç”¨æˆ·è¡Œä¸ºè¿½è¸ª
  trackUserAction(
    userId: string,
    action: string,
    context?: Record<string, any>
  ): void {
    const metric = {
      type: 'user_action',
      userId,
      action,
      context,
      timestamp: Date.now(),
    };
    
    this.sendMetric(metric);
  }
  
  private sendMetric(metric: any): void {
    // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿï¼ˆå¦‚DataDogã€New Relicç­‰ï¼‰
    fetch('/api/metrics', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(metric),
    }).catch(console.error);
  }
}

export const performanceMonitor = PerformanceMonitor.getInstance();
```

---

## ğŸ“‹ å…¨æ ˆå¼€å‘æ£€æŸ¥æ¸…å•

### å¼€å‘é˜¶æ®µå®Œæˆæ£€æŸ¥

#### åŠŸèƒ½å¼€å‘
- [ ] **APIè®¾è®¡**: RESTfulæ¥å£è®¾è®¡ç¬¦åˆè§„èŒƒ
- [ ] **æ•°æ®æµ**: å‰åç«¯æ•°æ®ä¼ è¾“æ ¼å¼ç»Ÿä¸€
- [ ] **é”™è¯¯å¤„ç†**: ç»Ÿä¸€çš„é”™è¯¯å¤„ç†æœºåˆ¶
- [ ] **æ•°æ®éªŒè¯**: å‰åç«¯éƒ½æœ‰æ•°æ®éªŒè¯
- [ ] **æƒé™æ§åˆ¶**: å®ç°äº†åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶

#### æ€§èƒ½ä¼˜åŒ–
- [ ] **ä»£ç åˆ†å‰²**: å¤§å‹ç»„ä»¶å’Œé¡µé¢å·²æ‡’åŠ è½½
- [ ] **å›¾ç‰‡ä¼˜åŒ–**: å®ç°äº†å“åº”å¼å›¾ç‰‡åŠ è½½
- [ ] **ç¼“å­˜ç­–ç•¥**: åˆç†ä½¿ç”¨äº†å‰ç«¯å’Œåç«¯ç¼“å­˜
- [ ] **æ•°æ®åº“**: æŸ¥è¯¢å·²ä¼˜åŒ–ï¼Œä½¿ç”¨äº†åˆé€‚çš„ç´¢å¼•

#### å®‰å…¨æ€§
- [ ] **è®¤è¯æˆæƒ**: JWTè®¤è¯æµç¨‹å®Œæ•´å¯é 
- [ ] **æ•°æ®ä¿æŠ¤**: æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨
- [ ] **XSSé˜²æŠ¤**: ç”¨æˆ·è¾“å…¥å·²è¿‡æ»¤å’Œè½¬ä¹‰
- [ ] **CSRFé˜²æŠ¤**: å®ç°äº†CSRFä¿æŠ¤æœºåˆ¶

### å‘å¸ƒå‰å¼ºåˆ¶æ£€æŸ¥

#### ä»£ç è´¨é‡
- [ ] **TypeScript**: æ— ç±»å‹é”™è¯¯ï¼Œç±»å‹è¦†ç›–ç‡95%+
- [ ] **ESLint**: ä»£ç è§„èŒƒæ£€æŸ¥é€šè¿‡
- [ ] **æµ‹è¯•è¦†ç›–**: å…³é”®åŠŸèƒ½æœ‰å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
- [ ] **æ„å»º**: ç”Ÿäº§æ„å»ºæˆåŠŸï¼Œæ— è­¦å‘Š

#### æ€§èƒ½åŸºå‡†
- [ ] **é¦–å±åŠ è½½**: < 3ç§’
- [ ] **APIå“åº”**: 95%çš„è¯·æ±‚ < 500ms
- [ ] **æ•°æ®åº“**: æŸ¥è¯¢æ—¶é—´ < 100ms
- [ ] **åŒ…å¤§å°**: ä¸»chunk < 250KB

#### ç›‘æ§å‘Šè­¦
- [ ] **é”™è¯¯ç›‘æ§**: å‰åç«¯é”™è¯¯è¿½è¸ªå·²é…ç½®
- [ ] **æ€§èƒ½ç›‘æ§**: å…³é”®æŒ‡æ ‡ç›‘æ§å·²å°±ä½
- [ ] **æ—¥å¿—ç³»ç»Ÿ**: ç»“æ„åŒ–æ—¥å¿—è®°å½•å®Œå–„
- [ ] **å‘Šè­¦æœºåˆ¶**: å¼‚å¸¸æƒ…å†µèƒ½åŠæ—¶é€šçŸ¥

---

**é€‚ç”¨é¡¹ç›®**: BiuBiuStarå…¨æ ˆç¤¾äº¤å¹³å°  
**æ›´æ–°é¢‘ç‡**: æ¶æ„é‡å¤§å˜æ›´æ—¶åŒæ­¥æ›´æ–°  
**å¼ºåˆ¶æ‰§è¡Œ**: æ‰€æœ‰P0çº§è§„åˆ™å¿…é¡»100%éµå¾ªï¼ŒP1çº§è§„åˆ™å»ºè®®90%ä»¥ä¸Šéµå¾ª