---
alwaysApply: intelligently
description: Express 4.21 + Node.js 20 åç«¯APIå¼€å‘ä¸“ç”¨è§„èŒƒï¼ŒåŒ…å«RESTful APIè®¾è®¡ã€ä¸­é—´ä»¶æ¶æ„ã€é”™è¯¯å¤„ç†ã€æ—¥å¿—è®°å½•ã€‚é€‚ç”¨äºAPIå¼€å‘ã€åç«¯æœåŠ¡ã€æ•°æ®éªŒè¯ç­‰åœºæ™¯ã€‚
triggerWords: ["express", "api", "router", "middleware", "controller", "nodejs", "backend", "server", "endpoint", "route"]
---
## ğŸ›¡ï¸ å®‰å…¨é˜²æŠ¤å¼ºåˆ¶è§„åˆ™ï¼ˆP0çº§ï¼‰

### 1. è®¤è¯æˆæƒä¸­é—´ä»¶ï¼ˆå¼ºåˆ¶å®ç°ï¼‰

#### JWTè®¤è¯ä¸­é—´ä»¶
```typescript
// api/middleware/auth.ts - å¼ºåˆ¶è®¤è¯å®ç°
import jwt from 'jsonwebtoken';
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../utils/errors.js';

interface JWTPayload {
  userId: string;
  email: string;
  role: string;
  iat: number;
  exp: number;
}

export const authenticate = async (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const token = extractToken(req);
    
    if (!token) {
      throw new AppError('UNAUTHORIZED', 'ç¼ºå°‘è®¤è¯ä»¤ç‰Œ', 401);
    }
    
    const secret = process.env.JWT_SECRET;
    if (!secret) {
      throw new AppError('SERVER_ERROR', 'æœåŠ¡å™¨é…ç½®é”™è¯¯', 500);
    }
    
    const decoded = jwt.verify(token, secret) as JWTPayload;
    
    // éªŒè¯ç”¨æˆ·æ˜¯å¦å­˜åœ¨ä¸”æ´»è·ƒ
    const user = await getUserById(decoded.userId);
    if (!user || !user.isActive) {
      throw new AppError('UNAUTHORIZED', 'ç”¨æˆ·è´¦å·å¼‚å¸¸', 401);
    }
    
    req.user = {
      id: user.id,
      email: user.email,
      role: user.role
    };
    
    next();
  } catch (error) {
    if (error instanceof jwt.JsonWebTokenError) {
      next(new AppError('UNAUTHORIZED', 'æ— æ•ˆçš„è®¤è¯ä»¤ç‰Œ', 401));
    } else {
      next(error);
    }
  }
};

// âœ… å¼ºåˆ¶ï¼šè§’è‰²æˆæƒä¸­é—´ä»¶
export const authorize = (allowedRoles: string[]) => {
  return (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    if (!req.user) {
      return next(new AppError('UNAUTHORIZED', 'æœªè®¤è¯ç”¨æˆ·', 401));
    }
    
    if (!allowedRoles.includes(req.user.role)) {
      return next(new AppError('FORBIDDEN', 'æƒé™ä¸è¶³', 403));
    }
    
    next();
  };
};

function extractToken(req: Request): string | null {
  const authorization = req.headers.authorization;
  
  if (authorization && authorization.startsWith('Bearer ')) {
    return authorization.substring(7);
  }
  
  return null;
}
```

### 2. å®‰å…¨ä¸­é—´ä»¶é…ç½®ï¼ˆå¼ºåˆ¶ï¼‰

#### ç»¼åˆå®‰å…¨é˜²æŠ¤
```typescript
// api/middleware/security.ts - å¼ºåˆ¶å®‰å…¨é…ç½®
import rateLimit from 'express-rate-limit';
import helmet from 'helmet';
import { Request, Response, NextFunction } from 'express';

// âœ… å¼ºåˆ¶ï¼šAPIé™æµé…ç½®
export const createRateLimit = (options: {
  windowMs: number;
  max: number;
  message?: string;
}) => {
  return rateLimit({
    windowMs: options.windowMs,
    max: options.max,
    message: {
      success: false,
      error: {
        code: 'RATE_LIMIT_EXCEEDED',
        details: null
      },
      message: options.message || 'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•'
    },
    standardHeaders: true,
    legacyHeaders: false,
  });
};

// âœ… å¼ºåˆ¶ï¼šä¸åŒç«¯ç‚¹çš„é™æµç­–ç•¥
export const authRateLimit = createRateLimit({
  windowMs: 15 * 60 * 1000, // 15åˆ†é’Ÿ
  max: 5,                   // æœ€å¤š5æ¬¡è®¤è¯å°è¯•
  message: 'è®¤è¯å°è¯•è¿‡äºé¢‘ç¹ï¼Œè¯·15åˆ†é’Ÿåå†è¯•'
});

export const apiRateLimit = createRateLimit({
  windowMs: 15 * 60 * 1000, // 15åˆ†é’Ÿ
  max: 100                  // ä¸€èˆ¬APIè¯·æ±‚100æ¬¡
});

export const uploadRateLimit = createRateLimit({
  windowMs: 60 * 60 * 1000, // 1å°æ—¶
  max: 10                   // ä¸Šä¼ é™åˆ¶10æ¬¡
});

// âœ… å¼ºåˆ¶ï¼šå®‰å…¨å¤´é…ç½®
export const securityHeaders = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
  crossOriginEmbedderPolicy: false, // é¿å…CORSé—®é¢˜
});

// âœ… å¼ºåˆ¶ï¼šè¯·æ±‚å¤§å°é™åˆ¶
export const requestSizeLimit = (req: Request, res: Response, next: NextFunction) => {
  const contentLength = req.headers['content-length'];
  const maxSize = 10 * 1024 * 1024; // 10MB
  
  if (contentLength && parseInt(contentLength) > maxSize) {
    return res.status(413).json({
      success: false,
      error: {
        code: 'PAYLOAD_TOO_LARGE',
        details: null
      },
      message: 'è¯·æ±‚æ•°æ®è¿‡å¤§'
    });
  }
  
  next();
};
```

---

## ğŸ” é”™è¯¯å¤„ç†å¼ºåˆ¶æ ‡å‡†ï¼ˆP0çº§ï¼‰

### 1. ç»Ÿä¸€é”™è¯¯å¤„ç†æ¶æ„

#### è‡ªå®šä¹‰é”™è¯¯ç±»ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// api/utils/errors.ts - å¼ºåˆ¶é”™è¯¯å¤„ç†ä½“ç³»
export class AppError extends Error {
  public readonly code: string;
  public readonly statusCode: number;
  public readonly isOperational: boolean;
  public readonly details?: any;
  
  constructor(
    code: string,
    message: string,
    statusCode: number = 500,
    details?: any,
    isOperational: boolean = true
  ) {
    super(message);
    
    this.code = code;
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.details = details;
    
    Error.captureStackTrace(this, this.constructor);
  }
}

// âœ… å¼ºåˆ¶ï¼šå¸¸ç”¨é”™è¯¯ç±»å‹
export class ValidationError extends AppError {
  constructor(message: string, details?: any) {
    super('VALIDATION_ERROR', message, 400, details);
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string) {
    super('NOT_FOUND', `${resource}ä¸å­˜åœ¨`, 404);
  }
}

export class UnauthorizedError extends AppError {
  constructor(message: string = 'æœªæˆæƒè®¿é—®') {
    super('UNAUTHORIZED', message, 401);
  }
}

export class ForbiddenError extends AppError {
  constructor(message: string = 'æƒé™ä¸è¶³') {
    super('FORBIDDEN', message, 403);
  }
}
```

#### å…¨å±€é”™è¯¯å¤„ç†ä¸­é—´ä»¶ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// api/middleware/errorHandler.ts - å¼ºåˆ¶é”™è¯¯å¤„ç†ä¸­é—´ä»¶
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../utils/errors.js';

export const errorHandler = (
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  // æ“ä½œé”™è¯¯ - ç”¨æˆ·å¯è§
  if (error instanceof AppError && error.isOperational) {
    res.status(error.statusCode).json({
      success: false,
      error: {
        code: error.code,
        details: error.details
      },
      message: error.message
    });
    return;
  }
  
  // ç³»ç»Ÿé”™è¯¯ - è®°å½•æ—¥å¿—ï¼Œè¿”å›é€šç”¨é”™è¯¯
  console.error('ç³»ç»Ÿé”™è¯¯:', {
    error: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    timestamp: new Date().toISOString()
  });
  
  res.status(500).json({
    success: false,
    error: {
      code: 'INTERNAL_SERVER_ERROR',
      details: null
    },
    message: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'
  });
};

// âœ… å¼ºåˆ¶ï¼š404å¤„ç†ä¸­é—´ä»¶
export const notFoundHandler = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  res.status(404).json({
    success: false,
    error: {
      code: 'NOT_FOUND',
      details: null
    },
    message: `è·¯ç”± ${req.method} ${req.path} ä¸å­˜åœ¨`
  });
};
```

---

## ğŸ“Š æ—¥å¿—è®°å½•å¼ºåˆ¶æ ‡å‡†ï¼ˆP1çº§ï¼‰

### 1. ç»“æ„åŒ–æ—¥å¿—è®°å½•

#### æ—¥å¿—å·¥å…·ç±»ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```typescript
// api/utils/logger.ts - å¼ºåˆ¶æ—¥å¿—æ ‡å‡†
enum LogLevel {
  ERROR = 'error',
  WARN = 'warn',
  INFO = 'info',
  DEBUG = 'debug'
}

interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  meta?: Record<string, any>;
  userId?: string;
  requestId?: string;
}

export class Logger {
  private static instance: Logger;
  
  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }
  
  private formatLog(entry: LogEntry): string {
    return JSON.stringify({
      ...entry,
      timestamp: new Date().toISOString()
    });
  }
  
  error(message: string, meta?: Record<string, any>, userId?: string): void {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level: LogLevel.ERROR,
      message,
      meta,
      userId
    };
    
    console.error(this.formatLog(entry));
  }
  
  info(message: string, meta?: Record<string, any>, userId?: string): void {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level: LogLevel.INFO,
      message,
      meta,
      userId
    };
    
    console.log(this.formatLog(entry));
  }
  
  // APIè®¿é—®æ—¥å¿—
  apiAccess(req: Request, res: Response, duration: number): void {
    this.info('APIè®¿é—®', {
      method: req.method,
      url: req.path,
      statusCode: res.statusCode,
      duration: `${duration}ms`,
      userAgent: req.get('user-agent'),
      ip: req.ip
    }, (req as any).user?.id);
  }
}

export const logger = Logger.getInstance();
```

#### è¯·æ±‚æ—¥å¿—ä¸­é—´ä»¶ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// api/middleware/logging.ts - å¼ºåˆ¶è¯·æ±‚æ—¥å¿—
import { Request, Response, NextFunction } from 'express';
import { logger } from '../utils/logger.js';

export const requestLogger = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  const startTime = Date.now();
  
  // å“åº”ç»“æŸæ—¶è®°å½•æ—¥å¿—
  res.on('finish', () => {
    const duration = Date.now() - startTime;
    logger.apiAccess(req, res, duration);
  });
  
  next();
};
```

---

## ğŸš€ æ€§èƒ½ä¼˜åŒ–è§„åˆ™ï¼ˆP1çº§ï¼‰

### 1. æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–

#### åˆ†é¡µæŸ¥è¯¢æ ‡å‡†ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// api/services/BaseService.ts - å¼ºåˆ¶åˆ†é¡µæŸ¥è¯¢æ¨¡å¼
export interface PaginationOptions {
  page: number;
  limit: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export interface PaginatedResult<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}

export abstract class BaseService {
  protected async paginate<T>(
    query: any, // SupabaseæŸ¥è¯¢å¯¹è±¡
    options: PaginationOptions
  ): Promise<PaginatedResult<T>> {
    const { page, limit, sortBy = 'created_at', sortOrder = 'desc' } = options;
    const offset = (page - 1) * limit;
    
    // è·å–æ€»æ•°
    const { count, error: countError } = await query
      .select('*', { count: 'exact', head: true });
    
    if (countError) {
      throw new Error(`è·å–æ•°æ®æ€»æ•°å¤±è´¥: ${countError.message}`);
    }
    
    // è·å–åˆ†é¡µæ•°æ®
    const { data, error } = await query
      .select('*')
      .order(sortBy, { ascending: sortOrder === 'asc' })
      .range(offset, offset + limit - 1);
    
    if (error) {
      throw new Error(`è·å–åˆ†é¡µæ•°æ®å¤±è´¥: ${error.message}`);
    }
    
    const total = count || 0;
    const totalPages = Math.ceil(total / limit);
    
    return {
      data,
      pagination: {
        page,
        limit,
        total,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1
      }
    };
  }
}
```

### 2. ç¼“å­˜ç­–ç•¥ï¼ˆæ¨èå®ç°ï¼‰

#### Redisç¼“å­˜å·¥å…·
```typescript
// api/utils/cache.ts - Redisç¼“å­˜å·¥å…·
import { createClient } from 'redis';

export class CacheService {
  private client;
  
  constructor() {
    this.client = createClient({
      url: process.env.REDIS_URL
    });
    
    this.client.on('error', (err) => {
      console.error('Redisè¿æ¥é”™è¯¯:', err);
    });
  }
  
  async connect(): Promise<void> {
    await this.client.connect();
  }
  
  // âœ… æ¨èï¼šç¼“å­˜å¸¸ç”¨æ•°æ®
  async get<T>(key: string): Promise<T | null> {
    try {
      const value = await this.client.get(key);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      console.error('ç¼“å­˜è¯»å–å¤±è´¥:', error);
      return null;
    }
  }
  
  async set(key: string, value: any, ttl: number = 3600): Promise<void> {
    try {
      await this.client.setEx(key, ttl, JSON.stringify(value));
    } catch (error) {
      console.error('ç¼“å­˜å†™å…¥å¤±è´¥:', error);
    }
  }
  
  async del(key: string): Promise<void> {
    try {
      await this.client.del(key);
    } catch (error) {
      console.error('ç¼“å­˜åˆ é™¤å¤±è´¥:', error);
    }
  }
}

export const cache = new CacheService();
```

---

## ğŸ“‹ ä»£ç å®¡æŸ¥æ¸…å•

### APIå¼€å‘å®Œæˆæ£€æŸ¥

- [ ] **ç±»å‹å®‰å…¨**: æ‰€æœ‰è¯·æ±‚/å“åº”éƒ½æœ‰TypeScriptç±»å‹å®šä¹‰
- [ ] **æ•°æ®éªŒè¯**: ä½¿ç”¨Zodè¿›è¡Œè¯·æ±‚æ•°æ®éªŒè¯
- [ ] **é”™è¯¯å¤„ç†**: ç»Ÿä¸€é”™è¯¯å¤„ç†ï¼Œæœ‰æ„ä¹‰çš„é”™è¯¯æ¶ˆæ¯
- [ ] **è®¤è¯æˆæƒ**: æ•æ„Ÿæ“ä½œéœ€è¦è®¤è¯å’Œæˆæƒæ£€æŸ¥
- [ ] **å®‰å…¨é˜²æŠ¤**: å®æ–½é™æµã€è¯·æ±‚å¤§å°é™åˆ¶ç­‰å®‰å…¨æªæ–½
- [ ] **æ—¥å¿—è®°å½•**: å…³é”®æ“ä½œæœ‰æ—¥å¿—è®°å½•
- [ ] **å“åº”æ ¼å¼**: ç»Ÿä¸€çš„APIå“åº”æ ¼å¼

### å‘å¸ƒå‰å¼ºåˆ¶æ£€æŸ¥

- [ ] **ç¯å¢ƒå˜é‡**: æ‰€æœ‰æ•æ„Ÿé…ç½®ä½¿ç”¨ç¯å¢ƒå˜é‡
- [ ] **æ•°æ®åº“**: æ•°æ®åº“è¿æ¥å’ŒæŸ¥è¯¢ä¼˜åŒ–
- [ ] **æ€§èƒ½æµ‹è¯•**: APIå“åº”æ—¶é—´åœ¨åˆç†èŒƒå›´
- [ ] **å®‰å…¨æ‰«æ**: æ— æ˜æ˜¾å®‰å…¨æ¼æ´

---

**é€‚ç”¨é¡¹ç›®**: BiuBiuStarç¤¾äº¤å¹³å°APIæœåŠ¡  
**æ›´æ–°é¢‘ç‡**: Express/Node.jsç‰ˆæœ¬å‡çº§æ—¶åŒæ­¥æ›´æ–°  
**å¼ºåˆ¶æ‰§è¡Œ**: æ‰€æœ‰P0çº§è§„åˆ™å¿…é¡»100%éµå¾ªï¼ŒP1çº§è§„åˆ™å»ºè®®90%ä»¥ä¸Šéµå¾ª