# Express 4.21 + Node.js 20 ä¸“ç”¨å¼€å‘è§„èŒƒ

> **æŠ€æœ¯æ ˆ**: Express 4.21.2 + Node.js 20 + TypeScript 5.8.3  
> **é€‚ç”¨é¡¹ç›®**: BiuBiuStarç¤¾äº¤å¹³å° - RESTful APIæœåŠ¡ç«¯

---

## ğŸ”¥ å¼ºåˆ¶æ‰§è¡Œè§„åˆ™ï¼ˆP0çº§ï¼‰

### 1. TypeScript APIå¼€å‘å¼ºåˆ¶æ ‡å‡†

#### è·¯ç”±å¤„ç†å™¨ç±»å‹å®‰å…¨
```typescript
// âœ… å¼ºåˆ¶ï¼šæ‰€æœ‰è·¯ç”±å¤„ç†å™¨å¿…é¡»æ˜ç¡®ç±»å‹
import { Request, Response, NextFunction } from 'express';

// è¯·æ±‚/å“åº”ç±»å‹å®šä¹‰
interface AuthenticatedRequest extends Request {
  user?: {
    id: string;
    email: string;
    role: 'user' | 'admin' | 'moderator';
  };
}

interface LoginRequest extends Request {
  body: {
    email: string;
    password: string;
  };
}

interface LoginResponse {
  success: boolean;
  data?: {
    user: User;
    token: string;
  };
  message?: string;
}

// âœ… å¼ºåˆ¶ï¼šè·¯ç”±å¤„ç†å™¨ç±»å‹åŒ–
export const login = async (
  req: LoginRequest,
  res: Response<LoginResponse>,
  next: NextFunction
): Promise<void> => {
  try {
    const { email, password } = req.body;
    
    // ä¸šåŠ¡é€»è¾‘
    const result = await authService.login(email, password);
    
    res.status(200).json({
      success: true,
      data: result
    });
  } catch (error) {
    next(error);
  }
};
```

#### APIå“åº”æ ‡å‡†åŒ–ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šç»Ÿä¸€APIå“åº”æ ¼å¼
interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  message?: string;
  error?: {
    code: string;
    details?: any;
  };
  pagination?: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

// âœ… å¼ºåˆ¶ï¼šå“åº”å·¥å…·å‡½æ•°
class ResponseHelper {
  static success<T>(data: T, message?: string): ApiResponse<T> {
    return {
      success: true,
      data,
      message
    };
  }
  
  static error(code: string, message: string, details?: any): ApiResponse {
    return {
      success: false,
      error: {
        code,
        details
      },
      message
    };
  }
  
  static paginated<T>(
    data: T[],
    pagination: {
      page: number;
      limit: number;
      total: number;
    }
  ): ApiResponse<T[]> {
    return {
      success: true,
      data,
      pagination: {
        ...pagination,
        totalPages: Math.ceil(pagination.total / pagination.limit)
      }
    };
  }
}
```

### 2. è·¯ç”±æ¶æ„å¼ºåˆ¶æ ‡å‡†

#### æ¨¡å—åŒ–è·¯ç”±ç»“æ„ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// api/routes/posts.ts - å¼ºåˆ¶ç»“æ„æ¨¡å¼
import express from 'express';
import { validate } from '../middleware/validation.js';
import { authenticate, authorize } from '../middleware/auth.js';
import { rateLimit } from '../middleware/rateLimit.js';
import * as postsController from '../controllers/posts.js';
import { createPostSchema, updatePostSchema } from '../schemas/posts.js';

const router = express.Router();

// âœ… å¼ºåˆ¶ï¼šè·¯ç”±å¿…é¡»åŒ…å«å®Œæ•´çš„ä¸­é—´ä»¶é“¾
router.get('/',
  rateLimit({ windowMs: 15 * 60 * 1000, max: 100 }), // é™æµ
  postsController.getPosts
);

router.post('/',
  authenticate,                           // è®¤è¯
  authorize(['user', 'admin']),          // æˆæƒ
  validate(createPostSchema),            // éªŒè¯
  rateLimit({ windowMs: 15 * 60 * 1000, max: 10 }), // é™æµ
  postsController.createPost
);

router.put('/:id',
  authenticate,
  authorize(['user', 'admin']),
  validate(updatePostSchema),
  postsController.updatePost
);

router.delete('/:id',
  authenticate,
  authorize(['admin', 'moderator']),
  postsController.deletePost
);

export default router;
```

#### æ§åˆ¶å™¨åˆ†ç¦»æ¨¡å¼ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// api/controllers/posts.ts - å¼ºåˆ¶æ§åˆ¶å™¨æ¨¡å¼
import { Request, Response, NextFunction } from 'express';
import { PostService } from '../services/PostService.js';
import { ResponseHelper } from '../utils/response.js';
import { AppError } from '../utils/errors.js';

export class PostsController {
  private postService: PostService;
  
  constructor() {
    this.postService = new PostService();
  }
  
  // âœ… å¼ºåˆ¶ï¼šæ§åˆ¶å™¨æ–¹æ³•å¿…é¡»async/await + é”™è¯¯å¤„ç†
  getPosts = async (
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const { page = 1, limit = 10, status = 'published' } = req.query;
      
      const result = await this.postService.getPosts({
        page: Number(page),
        limit: Number(limit),
        status: status as string
      });
      
      res.status(200).json(
        ResponseHelper.paginated(result.posts, {
          page: Number(page),
          limit: Number(limit),
          total: result.total
        })
      );
    } catch (error) {
      next(error);
    }
  };
  
  createPost = async (
    req: AuthenticatedRequest,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      if (!req.user) {
        throw new AppError('UNAUTHORIZED', 'æœªè®¤è¯ç”¨æˆ·', 401);
      }
      
      const postData = {
        ...req.body,
        authorId: req.user.id
      };
      
      const post = await this.postService.createPost(postData);
      
      res.status(201).json(
        ResponseHelper.success(post, 'å¸–å­åˆ›å»ºæˆåŠŸ')
      );
    } catch (error) {
      next(error);
    }
  };
}

// å¯¼å‡ºå®ä¾‹æ–¹æ³•
const postsController = new PostsController();
export const { getPosts, createPost } = postsController;
```

### 3. æ•°æ®éªŒè¯å¼ºåˆ¶æ ‡å‡†

#### ZodéªŒè¯æ¶æ„ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// api/schemas/posts.ts - å¼ºåˆ¶éªŒè¯æ¨¡å¼
import { z } from 'zod';

export const createPostSchema = z.object({
  body: z.object({
    title: z.string()
      .min(1, 'æ ‡é¢˜ä¸èƒ½ä¸ºç©º')
      .max(200, 'æ ‡é¢˜ä¸èƒ½è¶…è¿‡200å­—ç¬¦'),
    content: z.string()
      .min(1, 'å†…å®¹ä¸èƒ½ä¸ºç©º')
      .max(10000, 'å†…å®¹ä¸èƒ½è¶…è¿‡10000å­—ç¬¦'),
    tags: z.array(z.string())
      .max(10, 'æ ‡ç­¾æ•°é‡ä¸èƒ½è¶…è¿‡10ä¸ª')
      .optional(),
    coverImage: z.string()
      .url('å°é¢å›¾ç‰‡å¿…é¡»æ˜¯æœ‰æ•ˆURL')
      .optional(),
    status: z.enum(['draft', 'published'])
      .default('draft')
  })
});

export const updatePostSchema = z.object({
  params: z.object({
    id: z.string()
      .uuid('æ— æ•ˆçš„å¸–å­IDæ ¼å¼')
  }),
  body: z.object({
    title: z.string()
      .min(1, 'æ ‡é¢˜ä¸èƒ½ä¸ºç©º')
      .max(200, 'æ ‡é¢˜ä¸èƒ½è¶…è¿‡200å­—ç¬¦')
      .optional(),
    content: z.string()
      .min(1, 'å†…å®¹ä¸èƒ½ä¸ºç©º')
      .max(10000, 'å†…å®¹ä¸èƒ½è¶…è¿‡10000å­—ç¬¦')
      .optional(),
    tags: z.array(z.string())
      .max(10, 'æ ‡ç­¾æ•°é‡ä¸èƒ½è¶…è¿‡10ä¸ª')
      .optional(),
    status: z.enum(['draft', 'published', 'archived'])
      .optional()
  })
});

// âœ… å¼ºåˆ¶ï¼šå¯¼å‡ºç±»å‹å®šä¹‰
export type CreatePostRequest = z.infer<typeof createPostSchema>;
export type UpdatePostRequest = z.infer<typeof updatePostSchema>;
```

#### éªŒè¯ä¸­é—´ä»¶ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```typescript
// api/middleware/validation.ts - å¼ºåˆ¶éªŒè¯ä¸­é—´ä»¶
import { Request, Response, NextFunction } from 'express';
import { ZodSchema, ZodError } from 'zod';
import { AppError } from '../utils/errors.js';

export const validate = (schema: ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      // éªŒè¯è¯·æ±‚æ•°æ®
      const validated = schema.parse({
        body: req.body,
        params: req.params,
        query: req.query
      });
      
      // å°†éªŒè¯åçš„æ•°æ®æ›¿æ¢åŸå§‹æ•°æ®
      req.body = validated.body || req.body;
      req.params = validated.params || req.params;
      req.query = validated.query || req.query;
      
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        const validationErrors = error.errors.map(err => ({
          field: err.path.join('.'),
          message: err.message
        }));
        
        next(new AppError(
          'VALIDATION_ERROR',
          'è¯·æ±‚æ•°æ®éªŒè¯å¤±è´¥',
          400,
          { errors: validationErrors }
        ));
      } else {
        next(error);
      }
    }
  };
};
```

---

## ğŸ›¡ï¸ å®‰å…¨é˜²æŠ¤å¼ºåˆ¶è§„åˆ™ï¼ˆP0çº§ï¼‰

### 1. è®¤è¯æˆæƒä¸­é—´ä»¶ï¼ˆå¼ºåˆ¶å®ç°ï¼‰

#### JWTè®¤è¯ä¸­é—´ä»¶
```typescript
// api/middleware/auth.ts - å¼ºåˆ¶è®¤è¯å®ç°
import jwt from 'jsonwebtoken';
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../utils/errors.js';

interface JWTPayload {
  userId: string;
  email: string;
  role: string;
  iat: number;
  exp: number;
}

export const authenticate = async (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const token = extractToken(req);
    
    if (!token) {
      throw new AppError('UNAUTHORIZED', 'ç¼ºå°‘è®¤è¯ä»¤ç‰Œ', 401);
    }
    
    const secret = process.env.JWT_SECRET;
    if (!secret) {
      throw new AppError('SERVER_ERROR', 'æœåŠ¡å™¨é…ç½®é”™è¯¯', 500);
    }
    
    const decoded = jwt.verify(token, secret) as JWTPayload;
    
    // éªŒè¯ç”¨æˆ·æ˜¯å¦å­˜åœ¨ä¸”æ´»è·ƒ
    const user = await getUserById(decoded.userId);
    if (!user || !user.isActive) {
      throw new AppError('UNAUTHORIZED', 'ç”¨æˆ·è´¦å·å¼‚å¸¸', 401);
    }
    
    req.user = {
      id: user.id,
      email: user.email,
      role: user.role
    };
    
    next();
  } catch (error) {
    if (error instanceof jwt.JsonWebTokenError) {
      next(new AppError('UNAUTHORIZED', 'æ— æ•ˆçš„è®¤è¯ä»¤ç‰Œ', 401));
    } else {
      next(error);
    }
  }
};

// âœ… å¼ºåˆ¶ï¼šè§’è‰²æˆæƒä¸­é—´ä»¶
export const authorize = (allowedRoles: string[]) => {
  return (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    if (!req.user) {
      return next(new AppError('UNAUTHORIZED', 'æœªè®¤è¯ç”¨æˆ·', 401));
    }
    
    if (!allowedRoles.includes(req.user.role)) {
      return next(new AppError('FORBIDDEN', 'æƒé™ä¸è¶³', 403));
    }
    
    next();
  };
};

function extractToken(req: Request): string | null {
  const authorization = req.headers.authorization;
  
  if (authorization && authorization.startsWith('Bearer ')) {
    return authorization.substring(7);
  }
  
  return null;
}
```

### 2. å®‰å…¨ä¸­é—´ä»¶é…ç½®ï¼ˆå¼ºåˆ¶ï¼‰

#### ç»¼åˆå®‰å…¨é˜²æŠ¤
```typescript
// api/middleware/security.ts - å¼ºåˆ¶å®‰å…¨é…ç½®
import rateLimit from 'express-rate-limit';
import helmet from 'helmet';
import { Request, Response, NextFunction } from 'express';

// âœ… å¼ºåˆ¶ï¼šAPIé™æµé…ç½®
export const createRateLimit = (options: {
  windowMs: number;
  max: number;
  message?: string;
}) => {
  return rateLimit({
    windowMs: options.windowMs,
    max: options.max,
    message: {
      success: false,
      error: {
        code: 'RATE_LIMIT_EXCEEDED',
        details: null
      },
      message: options.message || 'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•'
    },
    standardHeaders: true,
    legacyHeaders: false,
  });
};

// âœ… å¼ºåˆ¶ï¼šä¸åŒç«¯ç‚¹çš„é™æµç­–ç•¥
export const authRateLimit = createRateLimit({
  windowMs: 15 * 60 * 1000, // 15åˆ†é’Ÿ
  max: 5,                   // æœ€å¤š5æ¬¡è®¤è¯å°è¯•
  message: 'è®¤è¯å°è¯•è¿‡äºé¢‘ç¹ï¼Œè¯·15åˆ†é’Ÿåå†è¯•'
});

export const apiRateLimit = createRateLimit({
  windowMs: 15 * 60 * 1000, // 15åˆ†é’Ÿ
  max: 100                  // ä¸€èˆ¬APIè¯·æ±‚100æ¬¡
});

export const uploadRateLimit = createRateLimit({
  windowMs: 60 * 60 * 1000, // 1å°æ—¶
  max: 10                   // ä¸Šä¼ é™åˆ¶10æ¬¡
});

// âœ… å¼ºåˆ¶ï¼šå®‰å…¨å¤´é…ç½®
export const securityHeaders = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
  crossOriginEmbedderPolicy: false, // é¿å…CORSé—®é¢˜
});

// âœ… å¼ºåˆ¶ï¼šè¯·æ±‚å¤§å°é™åˆ¶
export const requestSizeLimit = (req: Request, res: Response, next: NextFunction) => {
  const contentLength = req.headers['content-length'];
  const maxSize = 10 * 1024 * 1024; // 10MB
  
  if (contentLength && parseInt(contentLength) > maxSize) {
    return res.status(413).json({
      success: false,
      error: {
        code: 'PAYLOAD_TOO_LARGE',
        details: null
      },
      message: 'è¯·æ±‚æ•°æ®è¿‡å¤§'
    });
  }
  
  next();
};
```

---

## ğŸ” é”™è¯¯å¤„ç†å¼ºåˆ¶æ ‡å‡†ï¼ˆP0çº§ï¼‰

### 1. ç»Ÿä¸€é”™è¯¯å¤„ç†æ¶æ„

#### è‡ªå®šä¹‰é”™è¯¯ç±»ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// api/utils/errors.ts - å¼ºåˆ¶é”™è¯¯å¤„ç†ä½“ç³»
export class AppError extends Error {
  public readonly code: string;
  public readonly statusCode: number;
  public readonly isOperational: boolean;
  public readonly details?: any;
  
  constructor(
    code: string,
    message: string,
    statusCode: number = 500,
    details?: any,
    isOperational: boolean = true
  ) {
    super(message);
    
    this.code = code;
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.details = details;
    
    Error.captureStackTrace(this, this.constructor);
  }
}

// âœ… å¼ºåˆ¶ï¼šå¸¸ç”¨é”™è¯¯ç±»å‹
export class ValidationError extends AppError {
  constructor(message: string, details?: any) {
    super('VALIDATION_ERROR', message, 400, details);
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string) {
    super('NOT_FOUND', `${resource}ä¸å­˜åœ¨`, 404);
  }
}

export class UnauthorizedError extends AppError {
  constructor(message: string = 'æœªæˆæƒè®¿é—®') {
    super('UNAUTHORIZED', message, 401);
  }
}

export class ForbiddenError extends AppError {
  constructor(message: string = 'æƒé™ä¸è¶³') {
    super('FORBIDDEN', message, 403);
  }
}
```

#### å…¨å±€é”™è¯¯å¤„ç†ä¸­é—´ä»¶ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// api/middleware/errorHandler.ts - å¼ºåˆ¶é”™è¯¯å¤„ç†ä¸­é—´ä»¶
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../utils/errors.js';

export const errorHandler = (
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  // æ“ä½œé”™è¯¯ - ç”¨æˆ·å¯è§
  if (error instanceof AppError && error.isOperational) {
    res.status(error.statusCode).json({
      success: false,
      error: {
        code: error.code,
        details: error.details
      },
      message: error.message
    });
    return;
  }
  
  // ç³»ç»Ÿé”™è¯¯ - è®°å½•æ—¥å¿—ï¼Œè¿”å›é€šç”¨é”™è¯¯
  console.error('ç³»ç»Ÿé”™è¯¯:', {
    error: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    timestamp: new Date().toISOString()
  });
  
  res.status(500).json({
    success: false,
    error: {
      code: 'INTERNAL_SERVER_ERROR',
      details: null
    },
    message: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'
  });
};

// âœ… å¼ºåˆ¶ï¼š404å¤„ç†ä¸­é—´ä»¶
export const notFoundHandler = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  res.status(404).json({
    success: false,
    error: {
      code: 'NOT_FOUND',
      details: null
    },
    message: `è·¯ç”± ${req.method} ${req.path} ä¸å­˜åœ¨`
  });
};
```

---

## ğŸ“Š æ—¥å¿—è®°å½•å¼ºåˆ¶æ ‡å‡†ï¼ˆP1çº§ï¼‰

### 1. ç»“æ„åŒ–æ—¥å¿—è®°å½•

#### æ—¥å¿—å·¥å…·ç±»ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```typescript
// api/utils/logger.ts - å¼ºåˆ¶æ—¥å¿—æ ‡å‡†
enum LogLevel {
  ERROR = 'error',
  WARN = 'warn',
  INFO = 'info',
  DEBUG = 'debug'
}

interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  meta?: Record<string, any>;
  userId?: string;
  requestId?: string;
}

export class Logger {
  private static instance: Logger;
  
  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }
  
  private formatLog(entry: LogEntry): string {
    return JSON.stringify({
      ...entry,
      timestamp: new Date().toISOString()
    });
  }
  
  error(message: string, meta?: Record<string, any>, userId?: string): void {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level: LogLevel.ERROR,
      message,
      meta,
      userId
    };
    
    console.error(this.formatLog(entry));
  }
  
  info(message: string, meta?: Record<string, any>, userId?: string): void {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level: LogLevel.INFO,
      message,
      meta,
      userId
    };
    
    console.log(this.formatLog(entry));
  }
  
  // APIè®¿é—®æ—¥å¿—
  apiAccess(req: Request, res: Response, duration: number): void {
    this.info('APIè®¿é—®', {
      method: req.method,
      url: req.path,
      statusCode: res.statusCode,
      duration: `${duration}ms`,
      userAgent: req.get('user-agent'),
      ip: req.ip
    }, (req as any).user?.id);
  }
}

export const logger = Logger.getInstance();
```

#### è¯·æ±‚æ—¥å¿—ä¸­é—´ä»¶ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// api/middleware/logging.ts - å¼ºåˆ¶è¯·æ±‚æ—¥å¿—
import { Request, Response, NextFunction } from 'express';
import { logger } from '../utils/logger.js';

export const requestLogger = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  const startTime = Date.now();
  
  // å“åº”ç»“æŸæ—¶è®°å½•æ—¥å¿—
  res.on('finish', () => {
    const duration = Date.now() - startTime;
    logger.apiAccess(req, res, duration);
  });
  
  next();
};
```

---

## ğŸš€ æ€§èƒ½ä¼˜åŒ–è§„åˆ™ï¼ˆP1çº§ï¼‰

### 1. æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–

#### åˆ†é¡µæŸ¥è¯¢æ ‡å‡†ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// api/services/BaseService.ts - å¼ºåˆ¶åˆ†é¡µæŸ¥è¯¢æ¨¡å¼
export interface PaginationOptions {
  page: number;
  limit: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export interface PaginatedResult<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}

export abstract class BaseService {
  protected async paginate<T>(
    query: any, // SupabaseæŸ¥è¯¢å¯¹è±¡
    options: PaginationOptions
  ): Promise<PaginatedResult<T>> {
    const { page, limit, sortBy = 'created_at', sortOrder = 'desc' } = options;
    const offset = (page - 1) * limit;
    
    // è·å–æ€»æ•°
    const { count, error: countError } = await query
      .select('*', { count: 'exact', head: true });
    
    if (countError) {
      throw new Error(`è·å–æ•°æ®æ€»æ•°å¤±è´¥: ${countError.message}`);
    }
    
    // è·å–åˆ†é¡µæ•°æ®
    const { data, error } = await query
      .select('*')
      .order(sortBy, { ascending: sortOrder === 'asc' })
      .range(offset, offset + limit - 1);
    
    if (error) {
      throw new Error(`è·å–åˆ†é¡µæ•°æ®å¤±è´¥: ${error.message}`);
    }
    
    const total = count || 0;
    const totalPages = Math.ceil(total / limit);
    
    return {
      data,
      pagination: {
        page,
        limit,
        total,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1
      }
    };
  }
}
```

### 2. ç¼“å­˜ç­–ç•¥ï¼ˆæ¨èå®ç°ï¼‰

#### Redisç¼“å­˜å·¥å…·
```typescript
// api/utils/cache.ts - Redisç¼“å­˜å·¥å…·
import { createClient } from 'redis';

export class CacheService {
  private client;
  
  constructor() {
    this.client = createClient({
      url: process.env.REDIS_URL
    });
    
    this.client.on('error', (err) => {
      console.error('Redisè¿æ¥é”™è¯¯:', err);
    });
  }
  
  async connect(): Promise<void> {
    await this.client.connect();
  }
  
  // âœ… æ¨èï¼šç¼“å­˜å¸¸ç”¨æ•°æ®
  async get<T>(key: string): Promise<T | null> {
    try {
      const value = await this.client.get(key);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      console.error('ç¼“å­˜è¯»å–å¤±è´¥:', error);
      return null;
    }
  }
  
  async set(key: string, value: any, ttl: number = 3600): Promise<void> {
    try {
      await this.client.setEx(key, ttl, JSON.stringify(value));
    } catch (error) {
      console.error('ç¼“å­˜å†™å…¥å¤±è´¥:', error);
    }
  }
  
  async del(key: string): Promise<void> {
    try {
      await this.client.del(key);
    } catch (error) {
      console.error('ç¼“å­˜åˆ é™¤å¤±è´¥:', error);
    }
  }
}

export const cache = new CacheService();
```

---

## ğŸ“‹ ä»£ç å®¡æŸ¥æ¸…å•

### APIå¼€å‘å®Œæˆæ£€æŸ¥

- [ ] **ç±»å‹å®‰å…¨**: æ‰€æœ‰è¯·æ±‚/å“åº”éƒ½æœ‰TypeScriptç±»å‹å®šä¹‰
- [ ] **æ•°æ®éªŒè¯**: ä½¿ç”¨Zodè¿›è¡Œè¯·æ±‚æ•°æ®éªŒè¯
- [ ] **é”™è¯¯å¤„ç†**: ç»Ÿä¸€é”™è¯¯å¤„ç†ï¼Œæœ‰æ„ä¹‰çš„é”™è¯¯æ¶ˆæ¯
- [ ] **è®¤è¯æˆæƒ**: æ•æ„Ÿæ“ä½œéœ€è¦è®¤è¯å’Œæˆæƒæ£€æŸ¥
- [ ] **å®‰å…¨é˜²æŠ¤**: å®æ–½é™æµã€è¯·æ±‚å¤§å°é™åˆ¶ç­‰å®‰å…¨æªæ–½
- [ ] **æ—¥å¿—è®°å½•**: å…³é”®æ“ä½œæœ‰æ—¥å¿—è®°å½•
- [ ] **å“åº”æ ¼å¼**: ç»Ÿä¸€çš„APIå“åº”æ ¼å¼

### å‘å¸ƒå‰å¼ºåˆ¶æ£€æŸ¥

- [ ] **ç¯å¢ƒå˜é‡**: æ‰€æœ‰æ•æ„Ÿé…ç½®ä½¿ç”¨ç¯å¢ƒå˜é‡
- [ ] **æ•°æ®åº“**: æ•°æ®åº“è¿æ¥å’ŒæŸ¥è¯¢ä¼˜åŒ–
- [ ] **æ€§èƒ½æµ‹è¯•**: APIå“åº”æ—¶é—´åœ¨åˆç†èŒƒå›´
- [ ] **å®‰å…¨æ‰«æ**: æ— æ˜æ˜¾å®‰å…¨æ¼æ´

---

**é€‚ç”¨é¡¹ç›®**: BiuBiuStarç¤¾äº¤å¹³å°APIæœåŠ¡  
**æ›´æ–°é¢‘ç‡**: Express/Node.jsç‰ˆæœ¬å‡çº§æ—¶åŒæ­¥æ›´æ–°  
**å¼ºåˆ¶æ‰§è¡Œ**: æ‰€æœ‰P0çº§è§„åˆ™å¿…é¡»100%éµå¾ªï¼ŒP1çº§è§„åˆ™å»ºè®®90%ä»¥ä¸Šéµå¾ª