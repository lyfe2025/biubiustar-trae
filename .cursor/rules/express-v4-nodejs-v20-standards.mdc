---
alwaysApply: intelligently
description: Express 4.21 + Node.js 20 后端API开发专用规范，包含RESTful API设计、中间件架构、错误处理、日志记录。适用于API开发、后端服务、数据验证等场景。
triggerWords: ["express", "api", "router", "middleware", "controller", "nodejs", "backend", "server", "endpoint", "route"]
---
## 🛡️ 安全防护强制规则（P0级）

### 1. 认证授权中间件（强制实现）

#### JWT认证中间件
```typescript
// api/middleware/auth.ts - 强制认证实现
import jwt from 'jsonwebtoken';
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../utils/errors.js';

interface JWTPayload {
  userId: string;
  email: string;
  role: string;
  iat: number;
  exp: number;
}

export const authenticate = async (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const token = extractToken(req);
    
    if (!token) {
      throw new AppError('UNAUTHORIZED', '缺少认证令牌', 401);
    }
    
    const secret = process.env.JWT_SECRET;
    if (!secret) {
      throw new AppError('SERVER_ERROR', '服务器配置错误', 500);
    }
    
    const decoded = jwt.verify(token, secret) as JWTPayload;
    
    // 验证用户是否存在且活跃
    const user = await getUserById(decoded.userId);
    if (!user || !user.isActive) {
      throw new AppError('UNAUTHORIZED', '用户账号异常', 401);
    }
    
    req.user = {
      id: user.id,
      email: user.email,
      role: user.role
    };
    
    next();
  } catch (error) {
    if (error instanceof jwt.JsonWebTokenError) {
      next(new AppError('UNAUTHORIZED', '无效的认证令牌', 401));
    } else {
      next(error);
    }
  }
};

// ✅ 强制：角色授权中间件
export const authorize = (allowedRoles: string[]) => {
  return (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    if (!req.user) {
      return next(new AppError('UNAUTHORIZED', '未认证用户', 401));
    }
    
    if (!allowedRoles.includes(req.user.role)) {
      return next(new AppError('FORBIDDEN', '权限不足', 403));
    }
    
    next();
  };
};

function extractToken(req: Request): string | null {
  const authorization = req.headers.authorization;
  
  if (authorization && authorization.startsWith('Bearer ')) {
    return authorization.substring(7);
  }
  
  return null;
}
```

### 2. 安全中间件配置（强制）

#### 综合安全防护
```typescript
// api/middleware/security.ts - 强制安全配置
import rateLimit from 'express-rate-limit';
import helmet from 'helmet';
import { Request, Response, NextFunction } from 'express';

// ✅ 强制：API限流配置
export const createRateLimit = (options: {
  windowMs: number;
  max: number;
  message?: string;
}) => {
  return rateLimit({
    windowMs: options.windowMs,
    max: options.max,
    message: {
      success: false,
      error: {
        code: 'RATE_LIMIT_EXCEEDED',
        details: null
      },
      message: options.message || '请求过于频繁，请稍后再试'
    },
    standardHeaders: true,
    legacyHeaders: false,
  });
};

// ✅ 强制：不同端点的限流策略
export const authRateLimit = createRateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 5,                   // 最多5次认证尝试
  message: '认证尝试过于频繁，请15分钟后再试'
});

export const apiRateLimit = createRateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 100                  // 一般API请求100次
});

export const uploadRateLimit = createRateLimit({
  windowMs: 60 * 60 * 1000, // 1小时
  max: 10                   // 上传限制10次
});

// ✅ 强制：安全头配置
export const securityHeaders = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
  crossOriginEmbedderPolicy: false, // 避免CORS问题
});

// ✅ 强制：请求大小限制
export const requestSizeLimit = (req: Request, res: Response, next: NextFunction) => {
  const contentLength = req.headers['content-length'];
  const maxSize = 10 * 1024 * 1024; // 10MB
  
  if (contentLength && parseInt(contentLength) > maxSize) {
    return res.status(413).json({
      success: false,
      error: {
        code: 'PAYLOAD_TOO_LARGE',
        details: null
      },
      message: '请求数据过大'
    });
  }
  
  next();
};
```

---

## 🔍 错误处理强制标准（P0级）

### 1. 统一错误处理架构

#### 自定义错误类（强制）
```typescript
// api/utils/errors.ts - 强制错误处理体系
export class AppError extends Error {
  public readonly code: string;
  public readonly statusCode: number;
  public readonly isOperational: boolean;
  public readonly details?: any;
  
  constructor(
    code: string,
    message: string,
    statusCode: number = 500,
    details?: any,
    isOperational: boolean = true
  ) {
    super(message);
    
    this.code = code;
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.details = details;
    
    Error.captureStackTrace(this, this.constructor);
  }
}

// ✅ 强制：常用错误类型
export class ValidationError extends AppError {
  constructor(message: string, details?: any) {
    super('VALIDATION_ERROR', message, 400, details);
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string) {
    super('NOT_FOUND', `${resource}不存在`, 404);
  }
}

export class UnauthorizedError extends AppError {
  constructor(message: string = '未授权访问') {
    super('UNAUTHORIZED', message, 401);
  }
}

export class ForbiddenError extends AppError {
  constructor(message: string = '权限不足') {
    super('FORBIDDEN', message, 403);
  }
}
```

#### 全局错误处理中间件（强制）
```typescript
// api/middleware/errorHandler.ts - 强制错误处理中间件
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../utils/errors.js';

export const errorHandler = (
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  // 操作错误 - 用户可见
  if (error instanceof AppError && error.isOperational) {
    res.status(error.statusCode).json({
      success: false,
      error: {
        code: error.code,
        details: error.details
      },
      message: error.message
    });
    return;
  }
  
  // 系统错误 - 记录日志，返回通用错误
  console.error('系统错误:', {
    error: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    timestamp: new Date().toISOString()
  });
  
  res.status(500).json({
    success: false,
    error: {
      code: 'INTERNAL_SERVER_ERROR',
      details: null
    },
    message: '服务器内部错误'
  });
};

// ✅ 强制：404处理中间件
export const notFoundHandler = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  res.status(404).json({
    success: false,
    error: {
      code: 'NOT_FOUND',
      details: null
    },
    message: `路由 ${req.method} ${req.path} 不存在`
  });
};
```

---

## 📊 日志记录强制标准（P1级）

### 1. 结构化日志记录

#### 日志工具类（强制实现）
```typescript
// api/utils/logger.ts - 强制日志标准
enum LogLevel {
  ERROR = 'error',
  WARN = 'warn',
  INFO = 'info',
  DEBUG = 'debug'
}

interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  meta?: Record<string, any>;
  userId?: string;
  requestId?: string;
}

export class Logger {
  private static instance: Logger;
  
  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }
  
  private formatLog(entry: LogEntry): string {
    return JSON.stringify({
      ...entry,
      timestamp: new Date().toISOString()
    });
  }
  
  error(message: string, meta?: Record<string, any>, userId?: string): void {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level: LogLevel.ERROR,
      message,
      meta,
      userId
    };
    
    console.error(this.formatLog(entry));
  }
  
  info(message: string, meta?: Record<string, any>, userId?: string): void {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level: LogLevel.INFO,
      message,
      meta,
      userId
    };
    
    console.log(this.formatLog(entry));
  }
  
  // API访问日志
  apiAccess(req: Request, res: Response, duration: number): void {
    this.info('API访问', {
      method: req.method,
      url: req.path,
      statusCode: res.statusCode,
      duration: `${duration}ms`,
      userAgent: req.get('user-agent'),
      ip: req.ip
    }, (req as any).user?.id);
  }
}

export const logger = Logger.getInstance();
```

#### 请求日志中间件（强制）
```typescript
// api/middleware/logging.ts - 强制请求日志
import { Request, Response, NextFunction } from 'express';
import { logger } from '../utils/logger.js';

export const requestLogger = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  const startTime = Date.now();
  
  // 响应结束时记录日志
  res.on('finish', () => {
    const duration = Date.now() - startTime;
    logger.apiAccess(req, res, duration);
  });
  
  next();
};
```

---

## 🚀 性能优化规则（P1级）

### 1. 数据库查询优化

#### 分页查询标准（强制）
```typescript
// api/services/BaseService.ts - 强制分页查询模式
export interface PaginationOptions {
  page: number;
  limit: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export interface PaginatedResult<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}

export abstract class BaseService {
  protected async paginate<T>(
    query: any, // Supabase查询对象
    options: PaginationOptions
  ): Promise<PaginatedResult<T>> {
    const { page, limit, sortBy = 'created_at', sortOrder = 'desc' } = options;
    const offset = (page - 1) * limit;
    
    // 获取总数
    const { count, error: countError } = await query
      .select('*', { count: 'exact', head: true });
    
    if (countError) {
      throw new Error(`获取数据总数失败: ${countError.message}`);
    }
    
    // 获取分页数据
    const { data, error } = await query
      .select('*')
      .order(sortBy, { ascending: sortOrder === 'asc' })
      .range(offset, offset + limit - 1);
    
    if (error) {
      throw new Error(`获取分页数据失败: ${error.message}`);
    }
    
    const total = count || 0;
    const totalPages = Math.ceil(total / limit);
    
    return {
      data,
      pagination: {
        page,
        limit,
        total,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1
      }
    };
  }
}
```

### 2. 缓存策略（推荐实现）

#### Redis缓存工具
```typescript
// api/utils/cache.ts - Redis缓存工具
import { createClient } from 'redis';

export class CacheService {
  private client;
  
  constructor() {
    this.client = createClient({
      url: process.env.REDIS_URL
    });
    
    this.client.on('error', (err) => {
      console.error('Redis连接错误:', err);
    });
  }
  
  async connect(): Promise<void> {
    await this.client.connect();
  }
  
  // ✅ 推荐：缓存常用数据
  async get<T>(key: string): Promise<T | null> {
    try {
      const value = await this.client.get(key);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      console.error('缓存读取失败:', error);
      return null;
    }
  }
  
  async set(key: string, value: any, ttl: number = 3600): Promise<void> {
    try {
      await this.client.setEx(key, ttl, JSON.stringify(value));
    } catch (error) {
      console.error('缓存写入失败:', error);
    }
  }
  
  async del(key: string): Promise<void> {
    try {
      await this.client.del(key);
    } catch (error) {
      console.error('缓存删除失败:', error);
    }
  }
}

export const cache = new CacheService();
```

---

## 📋 代码审查清单

### API开发完成检查

- [ ] **类型安全**: 所有请求/响应都有TypeScript类型定义
- [ ] **数据验证**: 使用Zod进行请求数据验证
- [ ] **错误处理**: 统一错误处理，有意义的错误消息
- [ ] **认证授权**: 敏感操作需要认证和授权检查
- [ ] **安全防护**: 实施限流、请求大小限制等安全措施
- [ ] **日志记录**: 关键操作有日志记录
- [ ] **响应格式**: 统一的API响应格式

### 发布前强制检查

- [ ] **环境变量**: 所有敏感配置使用环境变量
- [ ] **数据库**: 数据库连接和查询优化
- [ ] **性能测试**: API响应时间在合理范围
- [ ] **安全扫描**: 无明显安全漏洞

---

**适用项目**: BiuBiuStar社交平台API服务  
**更新频率**: Express/Node.js版本升级时同步更新  
**强制执行**: 所有P0级规则必须100%遵循，P1级规则建议90%以上遵循