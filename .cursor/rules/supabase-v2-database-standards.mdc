---
alwaysApply: intelligently
description: Supabase 2.53 æ•°æ®åº“å¼€å‘ä¸“ç”¨è§„èŒƒï¼ŒåŒ…å«æ•°æ®åº“æ¶æ„è®¾è®¡ã€RLSç­–ç•¥ã€ç±»å‹é›†æˆã€æŸ¥è¯¢ä¼˜åŒ–ã€‚é€‚ç”¨äºæ•°æ®åº“è®¾è®¡ã€æ•°æ®å®‰å…¨ã€PostgreSQLæŸ¥è¯¢ç­‰åœºæ™¯ã€‚
triggerWords: ["supabase", "database", "sql", "table", "migration", "rls", "policy", "postgresql", "query", "schema"]
---
## ğŸ›¡ï¸ æ•°æ®å®‰å…¨å¼ºåˆ¶è§„åˆ™ï¼ˆP0çº§ï¼‰

### 1. æ•æ„Ÿæ•°æ®ä¿æŠ¤

#### æ•°æ®åŠ å¯†ç­–ç•¥ï¼ˆå¼ºåˆ¶ï¼‰
```sql
-- âœ… å¼ºåˆ¶ï¼šæ•æ„Ÿæ•°æ®å¿…é¡»åŠ å¯†å­˜å‚¨
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- åˆ›å»ºç”¨æˆ·è®¤è¯è¡¨ï¼ˆæ•æ„Ÿä¿¡æ¯åˆ†ç¦»ï¼‰
CREATE TABLE IF NOT EXISTS auth.user_credentials (
  user_id UUID PRIMARY KEY REFERENCES public.users(id) ON DELETE CASCADE,
  
  -- âœ… å¼ºåˆ¶ï¼šå¯†ç å¿…é¡»å“ˆå¸Œå­˜å‚¨
  password_hash VARCHAR(255) NOT NULL,
  
  -- âœ… å¼ºåˆ¶ï¼šæ•æ„Ÿä¿¡æ¯åŠ å¯†
  phone_encrypted TEXT,  -- pgp_sym_encrypt(phone, 'secret_key')
  id_number_encrypted TEXT,
  
  -- å®‰å…¨å…ƒæ•°æ®
  last_password_change TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  failed_login_attempts INTEGER DEFAULT 0,
  locked_until TIMESTAMP WITH TIME ZONE,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);

-- âœ… å¼ºåˆ¶ï¼šRLSä¿æŠ¤è®¤è¯è¡¨
ALTER TABLE auth.user_credentials ENABLE ROW LEVEL SECURITY;

-- åªæœ‰ç”¨æˆ·è‡ªå·±å’Œç³»ç»Ÿå¯ä»¥è®¿é—®
CREATE POLICY "ç”¨æˆ·åªèƒ½è®¿é—®è‡ªå·±çš„è®¤è¯ä¿¡æ¯" ON auth.user_credentials
FOR ALL USING (user_id = auth.uid());
```

#### æ•°æ®è„±æ•å‡½æ•°ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```sql
-- âœ… å¼ºåˆ¶ï¼šæ•æ„Ÿæ•°æ®è„±æ•å‡½æ•°
CREATE OR REPLACE FUNCTION public.mask_email(email TEXT)
RETURNS TEXT AS $$
BEGIN
  IF email IS NULL THEN RETURN NULL; END IF;
  
  RETURN 
    SUBSTRING(email FROM 1 FOR 2) || 
    '***' || 
    SUBSTRING(email FROM '@.*');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.mask_phone(phone TEXT)
RETURNS TEXT AS $$
BEGIN
  IF phone IS NULL THEN RETURN NULL; END IF;
  
  RETURN 
    SUBSTRING(phone FROM 1 FOR 3) || 
    '****' || 
    SUBSTRING(phone FROM LENGTH(phone) - 3);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- âœ… å¼ºåˆ¶ï¼šåˆ›å»ºè„±æ•è§†å›¾ä¾›å‰ç«¯ä½¿ç”¨
CREATE VIEW public.users_public AS
SELECT 
  id,
  username,
  display_name,
  avatar_url,
  bio,
  location,
  website,
  is_verified,
  follower_count,
  following_count,
  post_count,
  created_at,
  
  -- âœ… è„±æ•é‚®ç®±ï¼ˆä»…æ˜¾ç¤ºç»™ç”¨æˆ·è‡ªå·±ï¼‰
  CASE 
    WHEN id = auth.uid() THEN email
    ELSE mask_email(email)
  END as email_display
  
FROM public.users;
```

### 2. æ•°æ®å®¡è®¡å¼ºåˆ¶è¦æ±‚

#### å®¡è®¡æ—¥å¿—è¡¨ï¼ˆå¼ºåˆ¶åˆ›å»ºï¼‰
```sql
-- âœ… å¼ºåˆ¶ï¼šåˆ›å»ºå®¡è®¡æ—¥å¿—è¡¨
CREATE TABLE IF NOT EXISTS public.audit_logs (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  
  -- æ“ä½œä¿¡æ¯
  table_name VARCHAR(100) NOT NULL,
  operation VARCHAR(20) NOT NULL, -- INSERT, UPDATE, DELETE
  record_id UUID NOT NULL,
  
  -- ç”¨æˆ·ä¿¡æ¯
  user_id UUID REFERENCES public.users(id),
  user_role VARCHAR(50),
  
  -- æ•°æ®å˜æ›´
  old_values JSONB,
  new_values JSONB,
  changed_fields TEXT[],
  
  -- è¯·æ±‚ä¿¡æ¯
  ip_address INET,
  user_agent TEXT,
  request_id UUID,
  
  -- æ—¶é—´æˆ³
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);

-- âœ… å¼ºåˆ¶ï¼šå®¡è®¡æ—¥å¿—ç´¢å¼•
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_audit_logs_table_record
ON public.audit_logs(table_name, record_id);

CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_audit_logs_user_created
ON public.audit_logs(user_id, created_at DESC);

CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_audit_logs_created_at
ON public.audit_logs(created_at DESC);
```

#### å®¡è®¡è§¦å‘å™¨ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```sql
-- âœ… å¼ºåˆ¶ï¼šé€šç”¨å®¡è®¡è§¦å‘å™¨å‡½æ•°
CREATE OR REPLACE FUNCTION public.audit_trigger_function()
RETURNS TRIGGER AS $$
DECLARE
  old_data JSONB;
  new_data JSONB;
  excluded_columns TEXT[] := ARRAY['updated_at'];
BEGIN
  -- è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
  IF TG_OP = 'DELETE' THEN
    old_data = to_jsonb(OLD);
    INSERT INTO public.audit_logs (
      table_name, operation, record_id, user_id,
      old_values, ip_address, created_at
    ) VALUES (
      TG_TABLE_NAME, TG_OP, OLD.id, auth.uid(),
      old_data, inet_client_addr(), NOW()
    );
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    old_data = to_jsonb(OLD);
    new_data = to_jsonb(NEW);
    
    -- åªè®°å½•å®é™…å˜æ›´çš„å­—æ®µ
    IF old_data != new_data THEN
      INSERT INTO public.audit_logs (
        table_name, operation, record_id, user_id,
        old_values, new_values, ip_address, created_at
      ) VALUES (
        TG_TABLE_NAME, TG_OP, NEW.id, auth.uid(),
        old_data, new_data, inet_client_addr(), NOW()
      );
    END IF;
    RETURN NEW;
  ELSIF TG_OP = 'INSERT' THEN
    new_data = to_jsonb(NEW);
    INSERT INTO public.audit_logs (
      table_name, operation, record_id, user_id,
      new_values, ip_address, created_at
    ) VALUES (
      TG_TABLE_NAME, TG_OP, NEW.id, auth.uid(),
      new_data, inet_client_addr(), NOW()
    );
    RETURN NEW;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- âœ… å¼ºåˆ¶ï¼šä¸ºé‡è¦è¡¨åˆ›å»ºå®¡è®¡è§¦å‘å™¨
CREATE TRIGGER audit_users_trigger
  AFTER INSERT OR UPDATE OR DELETE ON public.users
  FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_function();

CREATE TRIGGER audit_posts_trigger
  AFTER INSERT OR UPDATE OR DELETE ON public.posts
  FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_function();
```

---

## ğŸ“Š TypeScripté›†æˆæ ‡å‡†ï¼ˆP0çº§ï¼‰

### 1. æ•°æ®åº“ç±»å‹å®šä¹‰å¼ºåˆ¶æ ‡å‡†

#### è‡ªåŠ¨ç±»å‹ç”Ÿæˆï¼ˆå¼ºåˆ¶é…ç½®ï¼‰
```typescript
// âœ… å¼ºåˆ¶ï¼šä½¿ç”¨Supabase CLIç”Ÿæˆç±»å‹
// å‘½ä»¤: supabase gen types typescript --project-id your-project-id > src/types/database.types.ts

// src/types/database.types.ts - è‡ªåŠ¨ç”Ÿæˆ
export interface Database {
  public: {
    Tables: {
      users: {
        Row: {
          id: string;
          email: string;
          username: string;
          display_name: string | null;
          avatar_url: string | null;
          bio: string | null;
          location: string | null;
          website: string | null;
          is_verified: boolean;
          role: 'user' | 'moderator' | 'admin' | 'super_admin';
          follower_count: number;
          following_count: number;
          post_count: number;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          email: string;
          username: string;
          display_name?: string | null;
          avatar_url?: string | null;
          bio?: string | null;
          location?: string | null;
          website?: string | null;
          is_verified?: boolean;
          role?: 'user' | 'moderator' | 'admin' | 'super_admin';
          follower_count?: number;
          following_count?: number;
          post_count?: number;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          id?: string;
          email?: string;
          username?: string;
          display_name?: string | null;
          avatar_url?: string | null;
          bio?: string | null;
          location?: string | null;
          website?: string | null;
          is_verified?: boolean;
          role?: 'user' | 'moderator' | 'admin' | 'super_admin';
          follower_count?: number;
          following_count?: number;
          post_count?: number;
          created_at?: string;
          updated_at?: string;
        };
      };
      // ... å…¶ä»–è¡¨ç±»å‹å®šä¹‰
    };
    Views: {
      // è§†å›¾ç±»å‹å®šä¹‰
    };
    Functions: {
      // å‡½æ•°ç±»å‹å®šä¹‰
    };
  };
}
```

#### ç±»å‹å®‰å…¨çš„Supabaseå®¢æˆ·ç«¯ï¼ˆå¼ºåˆ¶ï¼‰
```typescript
// src/lib/supabase.ts - å¼ºåˆ¶ç±»å‹å®‰å…¨é…ç½®
import { createClient } from '@supabase/supabase-js';
import { Database } from '@/types/database.types';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('ç¼ºå°‘Supabaseç¯å¢ƒå˜é‡');
}

// âœ… å¼ºåˆ¶ï¼šç±»å‹åŒ–Supabaseå®¢æˆ·ç«¯
export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true
  }
});

// âœ… å¼ºåˆ¶ï¼šç±»å‹åˆ«åå¯¼å‡º
export type Tables<T extends keyof Database['public']['Tables']> = 
  Database['public']['Tables'][T]['Row'];

export type InsertTables<T extends keyof Database['public']['Tables']> = 
  Database['public']['Tables'][T]['Insert'];

export type UpdateTables<T extends keyof Database['public']['Tables']> = 
  Database['public']['Tables'][T]['Update'];

// âœ… å¼ºåˆ¶ï¼šä¸šåŠ¡ç±»å‹å®šä¹‰
export type User = Tables<'users'>;
export type Post = Tables<'posts'>;
export type Comment = Tables<'comments'>;
export type Like = Tables<'likes'>;
export type Follow = Tables<'follows'>;

export type CreateUserData = InsertTables<'users'>;
export type UpdateUserData = UpdateTables<'users'>;
export type CreatePostData = InsertTables<'posts'>;
export type UpdatePostData = UpdateTables<'posts'>;
```

### 2. æ•°æ®è®¿é—®å±‚å¼ºåˆ¶æ ‡å‡†

#### Repositoryæ¨¡å¼ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```typescript
// src/repositories/BaseRepository.ts - å¼ºåˆ¶åŸºç¡€Repository
import { supabase } from '@/lib/supabase';
import { Database } from '@/types/database.types';

export abstract class BaseRepository<T extends keyof Database['public']['Tables']> {
  protected tableName: T;
  
  constructor(tableName: T) {
    this.tableName = tableName;
  }
  
  // âœ… å¼ºåˆ¶ï¼šç±»å‹å®‰å…¨çš„åŸºç¡€CRUDæ“ä½œ
  async findById(id: string): Promise<Tables<T> | null> {
    const { data, error } = await supabase
      .from(this.tableName)
      .select('*')
      .eq('id', id)
      .single();
    
    if (error) {
      throw new DatabaseError(`æŸ¥è¯¢${this.tableName}å¤±è´¥`, error);
    }
    
    return data;
  }
  
  async create(data: InsertTables<T>): Promise<Tables<T>> {
    const { data: result, error } = await supabase
      .from(this.tableName)
      .insert(data)
      .select()
      .single();
    
    if (error) {
      throw new DatabaseError(`åˆ›å»º${this.tableName}å¤±è´¥`, error);
    }
    
    return result;
  }
  
  async update(id: string, data: UpdateTables<T>): Promise<Tables<T>> {
    const { data: result, error } = await supabase
      .from(this.tableName)
      .update(data)
      .eq('id', id)
      .select()
      .single();
    
    if (error) {
      throw new DatabaseError(`æ›´æ–°${this.tableName}å¤±è´¥`, error);
    }
    
    return result;
  }
  
  async delete(id: string): Promise<void> {
    const { error } = await supabase
      .from(this.tableName)
      .delete()
      .eq('id', id);
    
    if (error) {
      throw new DatabaseError(`åˆ é™¤${this.tableName}å¤±è´¥`, error);
    }
  }
}

// âœ… å¼ºåˆ¶ï¼šæ•°æ®åº“é”™è¯¯ç±»
export class DatabaseError extends Error {
  constructor(
    message: string,
    public supabaseError: any,
    public code?: string
  ) {
    super(message);
    this.name = 'DatabaseError';
    this.code = supabaseError?.code || code;
  }
}
```

#### å…·ä½“Repositoryå®ç°ï¼ˆå¼ºåˆ¶æ¨¡å¼ï¼‰
```typescript
// src/repositories/UserRepository.ts - å¼ºåˆ¶ç”¨æˆ·Repository
import { BaseRepository } from './BaseRepository';
import { User, CreateUserData, UpdateUserData } from '@/lib/supabase';

export class UserRepository extends BaseRepository<'users'> {
  constructor() {
    super('users');
  }
  
  // âœ… å¼ºåˆ¶ï¼šä¸šåŠ¡ç‰¹å®šæŸ¥è¯¢æ–¹æ³•
  async findByEmail(email: string): Promise<User | null> {
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .eq('email', email)
      .single();
    
    if (error && error.code !== 'PGRST116') { // æœªæ‰¾åˆ°è®°å½•
      throw new DatabaseError('æ ¹æ®é‚®ç®±æŸ¥è¯¢ç”¨æˆ·å¤±è´¥', error);
    }
    
    return data;
  }
  
  async findByUsername(username: string): Promise<User | null> {
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .eq('username', username)
      .single();
    
    if (error && error.code !== 'PGRST116') {
      throw new DatabaseError('æ ¹æ®ç”¨æˆ·åæŸ¥è¯¢ç”¨æˆ·å¤±è´¥', error);
    }
    
    return data;
  }
  
  // âœ… å¼ºåˆ¶ï¼šåˆ†é¡µæŸ¥è¯¢
  async findWithPagination(options: {
    page: number;
    limit: number;
    search?: string;
    role?: string;
  }): Promise<{ users: User[]; total: number }> {
    const { page, limit, search, role } = options;
    const offset = (page - 1) * limit;
    
    let query = supabase
      .from('users')
      .select('*', { count: 'exact' });
    
    if (search) {
      query = query.or(`username.ilike.%${search}%,display_name.ilike.%${search}%`);
    }
    
    if (role) {
      query = query.eq('role', role);
    }
    
    const { data, error, count } = await query
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);
    
    if (error) {
      throw new DatabaseError('åˆ†é¡µæŸ¥è¯¢ç”¨æˆ·å¤±è´¥', error);
    }
    
    return {
      users: data || [],
      total: count || 0
    };
  }
  
  // âœ… å¼ºåˆ¶ï¼šå…³æ³¨å…³ç³»æ“ä½œ
  async follow(followerId: string, followingId: string): Promise<void> {
    const { error } = await supabase
      .from('follows')
      .insert({
        follower_id: followerId,
        following_id: followingId
      });
    
    if (error) {
      throw new DatabaseError('å…³æ³¨ç”¨æˆ·å¤±è´¥', error);
    }
  }
  
  async unfollow(followerId: string, followingId: string): Promise<void> {
    const { error } = await supabase
      .from('follows')
      .delete()
      .eq('follower_id', followerId)
      .eq('following_id', followingId);
    
    if (error) {
      throw new DatabaseError('å–æ¶ˆå…³æ³¨å¤±è´¥', error);
    }
  }
}

// âœ… å¼ºåˆ¶ï¼šå¯¼å‡ºå•ä¾‹å®ä¾‹
export const userRepository = new UserRepository();
```

---

## ğŸš€ æŸ¥è¯¢ä¼˜åŒ–å¼ºåˆ¶è§„åˆ™ï¼ˆP1çº§ï¼‰

### 1. æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–

#### æ‰¹é‡æ“ä½œä¼˜åŒ–ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```typescript
// src/services/PostService.ts - å¼ºåˆ¶æ‰¹é‡æ“ä½œä¼˜åŒ–
export class PostService {
  // âœ… å¼ºåˆ¶ï¼šæ‰¹é‡è·å–å¸–å­åŠå…³è”æ•°æ®
  async getPostsWithUserData(postIds: string[]): Promise<(Post & { user: User })[]> {
    // ä½¿ç”¨joinæŸ¥è¯¢å‡å°‘ç½‘ç»œè¯·æ±‚
    const { data, error } = await supabase
      .from('posts')
      .select(`
        *,
        user:user_id (
          id,
          username,
          display_name,
          avatar_url,
          is_verified
        )
      `)
      .in('id', postIds)
      .eq('status', 'published')
      .order('created_at', { ascending: false });
    
    if (error) {
      throw new DatabaseError('æ‰¹é‡è·å–å¸–å­å¤±è´¥', error);
    }
    
    return data || [];
  }
  
  // âœ… å¼ºåˆ¶ï¼šä¼˜åŒ–çš„ç”¨æˆ·åŠ¨æ€æŸ¥è¯¢
  async getUserFeed(userId: string, options: {
    page: number;
    limit: number;
  }): Promise<{ posts: (Post & { user: User })[], total: number }> {
    const { page, limit } = options;
    const offset = (page - 1) * limit;
    
    // ä½¿ç”¨CTEæˆ–å­æŸ¥è¯¢ä¼˜åŒ–æ€§èƒ½
    const { data, error, count } = await supabase
      .from('posts')
      .select(`
        *,
        user:user_id (
          id,
          username,
          display_name,
          avatar_url,
          is_verified
        )
      `, { count: 'exact' })
      .eq('status', 'published')
      .in('user_id', [
        // å­æŸ¥è¯¢ï¼šè·å–ç”¨æˆ·å…³æ³¨çš„äººçš„IDåˆ—è¡¨
        supabase
          .from('follows')
          .select('following_id')
          .eq('follower_id', userId)
      ])
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);
    
    if (error) {
      throw new DatabaseError('è·å–ç”¨æˆ·åŠ¨æ€å¤±è´¥', error);
    }
    
    return {
      posts: data || [],
      total: count || 0
    };
  }
}
```

### 2. å®æ—¶è®¢é˜…ç®¡ç†

#### å®æ—¶æ•°æ®è®¢é˜…ï¼ˆå¼ºåˆ¶å®ç°ï¼‰
```typescript
// src/hooks/useRealtimeSubscription.ts - å¼ºåˆ¶å®æ—¶è®¢é˜…Hook
import { useEffect, useState } from 'react';
import { supabase } from '@/lib/supabase';
import { RealtimeChannel } from '@supabase/supabase-js';

interface UseRealtimeSubscriptionOptions<T> {
  table: string;
  filter?: string;
  onInsert?: (payload: T) => void;
  onUpdate?: (payload: T) => void;
  onDelete?: (payload: { old_record: T }) => void;
}

// âœ… å¼ºåˆ¶ï¼šç±»å‹å®‰å…¨çš„å®æ—¶è®¢é˜…Hook
export function useRealtimeSubscription<T = any>({
  table,
  filter,
  onInsert,
  onUpdate,
  onDelete,
}: UseRealtimeSubscriptionOptions<T>) {
  const [channel, setChannel] = useState<RealtimeChannel | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  
  useEffect(() => {
    let channelName = `public:${table}`;
    if (filter) {
      channelName += `:${filter}`;
    }
    
    const newChannel = supabase
      .channel(channelName)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: table,
          filter: filter
        },
        (payload) => {
          console.log('Realtime event:', payload);
          
          switch (payload.eventType) {
            case 'INSERT':
              onInsert?.(payload.new as T);
              break;
            case 'UPDATE':
              onUpdate?.(payload.new as T);
              break;
            case 'DELETE':
              onDelete?.({ old_record: payload.old as T });
              break;
          }
        }
      )
      .subscribe((status) => {
        console.log('Subscription status:', status);
        setIsConnected(status === 'SUBSCRIBED');
      });
    
    setChannel(newChannel);
    
    return () => {
      console.log('Unsubscribing from channel:', channelName);
      newChannel.unsubscribe();
    };
  }, [table, filter, onInsert, onUpdate, onDelete]);
  
  return { channel, isConnected };
}

// âœ… å¼ºåˆ¶ï¼šä½¿ç”¨ç¤ºä¾‹
// const { isConnected } = useRealtimeSubscription<Post>({
//   table: 'posts',
//   filter: 'status=eq.published',
//   onInsert: (post) => {
//     console.log('æ–°å¸–å­:', post);
//     // æ›´æ–°æœ¬åœ°çŠ¶æ€
//   },
//   onUpdate: (post) => {
//     console.log('å¸–å­æ›´æ–°:', post);
//     // æ›´æ–°æœ¬åœ°çŠ¶æ€
//   }
// });
```

---

## ğŸ“‹ ä»£ç å®¡æŸ¥æ¸…å•

### æ•°æ®åº“è®¾è®¡å®Œæˆæ£€æŸ¥

- [ ] **è¡¨ç»“æ„**: æ‰€æœ‰è¡¨éƒ½æœ‰UUIDä¸»é”®ã€å®¡è®¡å­—æ®µã€é€‚å½“çš„å¤–é”®çº¦æŸ
- [ ] **RLSç­–ç•¥**: æ‰€æœ‰è¡¨éƒ½å¯ç”¨äº†RLSå¹¶æœ‰é€‚å½“çš„å®‰å…¨ç­–ç•¥
- [ ] **ç´¢å¼•ä¼˜åŒ–**: å¤–é”®ã€æŸ¥è¯¢é¢‘ç¹å­—æ®µéƒ½æœ‰ç›¸åº”ç´¢å¼•
- [ ] **ç±»å‹å®šä¹‰**: ä½¿ç”¨æšä¸¾ç±»å‹çº¦æŸçŠ¶æ€å­—æ®µ
- [ ] **å®¡è®¡æ—¥å¿—**: é‡è¦è¡¨éƒ½æœ‰å®¡è®¡è§¦å‘å™¨
- [ ] **æ•°æ®è„±æ•**: æ•æ„Ÿæ•°æ®æœ‰è„±æ•å¤„ç†

### TypeScripté›†æˆæ£€æŸ¥

- [ ] **ç±»å‹å®‰å…¨**: ä½¿ç”¨è‡ªåŠ¨ç”Ÿæˆçš„æ•°æ®åº“ç±»å‹
- [ ] **Repositoryæ¨¡å¼**: æ•°æ®è®¿é—®å±‚æœ‰é€‚å½“çš„æŠ½è±¡
- [ ] **é”™è¯¯å¤„ç†**: æ•°æ®åº“æ“ä½œæœ‰ç»Ÿä¸€çš„é”™è¯¯å¤„ç†
- [ ] **æŸ¥è¯¢ä¼˜åŒ–**: å¤æ‚æŸ¥è¯¢ä½¿ç”¨äº†é€‚å½“çš„ä¼˜åŒ–ç­–ç•¥

### å®‰å…¨æ€§æ£€æŸ¥

- [ ] **è®¤è¯æˆæƒ**: RLSç­–ç•¥æ­£ç¡®å®ç°äº†æƒé™æ§åˆ¶
- [ ] **æ•°æ®åŠ å¯†**: æ•æ„Ÿæ•°æ®ä½¿ç”¨äº†åŠ å¯†å­˜å‚¨
- [ ] **SQLæ³¨å…¥**: æ‰€æœ‰æŸ¥è¯¢éƒ½ä½¿ç”¨äº†å‚æ•°åŒ–æŸ¥è¯¢
- [ ] **å®¡è®¡è¿½è¸ª**: é‡è¦æ“ä½œéƒ½æœ‰å®¡è®¡è®°å½•

---

**é€‚ç”¨é¡¹ç›®**: BiuBiuStarç¤¾äº¤å¹³å°æ•°æ®åº“å±‚  
**æ›´æ–°é¢‘ç‡**: Supabaseç‰ˆæœ¬å‡çº§æ—¶åŒæ­¥æ›´æ–°  
**å¼ºåˆ¶æ‰§è¡Œ**: æ‰€æœ‰P0çº§è§„åˆ™å¿…é¡»100%éµå¾ªï¼ŒP1çº§è§„åˆ™å»ºè®®95%ä»¥ä¸Šéµå¾ª